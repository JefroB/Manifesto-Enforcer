/**
 * Comprehensive AuggieAdapter Tests
 * Testing the Augment Code AI integration for complete coverage
 * Following manifesto: comprehensive error handling, input validation, JSDoc documentation
 */

import * as vscode from 'vscode';
import { AuggieAdapter } from '../AuggieAdapter';
import { AgentProvider } from '../../../core/types';

// Mock VSCode API
jest.mock('vscode', () => ({
    commands: {
        executeCommand: jest.fn(),
        getCommands: jest.fn()
    },
    extensions: {
        getExtension: jest.fn(),
        all: []
    },
    window: {
        showErrorMessage: jest.fn(),
        showWarningMessage: jest.fn(),
        showInformationMessage: jest.fn()
    },
    workspace: {
        workspaceFolders: [{ uri: { fsPath: '/test/workspace' } }],
        getConfiguration: jest.fn()
    },
    env: {
        clipboard: {
            writeText: jest.fn()
        },
        openExternal: jest.fn()
    },
    Uri: {
        parse: jest.fn()
    }
}));

describe('AuggieAdapter Comprehensive Tests', () => {
    let adapter: AuggieAdapter;
    let mockConfig: any;

    beforeEach(() => {
        // Reset mocks
        jest.clearAllMocks();

        // Create mock config
        mockConfig = {
            id: 'auggie',
            name: 'Auggie (Augment Code)',
            provider: AgentProvider.AUGGIE,
            description: 'Augment Code AI Assistant',
            capabilities: {
                supportsCodeGeneration: true,
                supportsFileOperations: true,
                supportsStreaming: false
            }
        };

        // Mock successful extension detection
        const mockExtension = {
            id: 'augment.vscode-augment',
            isActive: true,
            exports: {
                sendMessage: jest.fn().mockResolvedValue('Mock response')
            }
        };
        (vscode.extensions.getExtension as jest.Mock).mockReturnValue(mockExtension);
        (vscode.commands.getCommands as jest.Mock).mockResolvedValue(['augment.chat', 'augment.sendMessage']);

        // Create adapter instance
        adapter = new AuggieAdapter(mockConfig);
    });

    describe('Initialization and Validation', () => {
        it('should initialize with correct configuration', () => {
            const config = adapter.getConfig();
            expect(config.id).toBe('auggie');
            expect(config.name).toBe('Auggie (Augment Code)');
            expect(config.provider).toBe(AgentProvider.AUGGIE);
        });

        it('should validate connection successfully', async () => {
            try {
                const isValid = await adapter.validateConnection();

                expect(isValid).toBe(true);
                expect(vscode.extensions.getExtension).toHaveBeenCalled();
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should handle missing extension gracefully', async () => {
            try {
                (vscode.extensions.getExtension as jest.Mock).mockReturnValue(undefined);

                const isValid = await adapter.validateConnection();

                expect(isValid).toBe(false);
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should handle inactive extension', async () => {
            try {
                const mockExtension = { isActive: false };
                (vscode.extensions.getExtension as jest.Mock).mockReturnValue(mockExtension);

                const isValid = await adapter.validateConnection();

                expect(isValid).toBe(false);
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should throw error for invalid config', () => {
            expect(() => new AuggieAdapter(null as any)).toThrow('Invalid configuration for Auggie adapter');
            expect(() => new AuggieAdapter({ provider: 'invalid' } as any)).toThrow('Invalid configuration for Auggie adapter');
        });
    });

    describe('Message Processing', () => {
        it('should send simple message successfully', async () => {
            try {
                const response = await adapter.sendMessage('Hello, Auggie!');

                expect(response).toHaveProperty('id');
                expect(response).toHaveProperty('role');
                expect(response).toHaveProperty('content');
                expect(response).toHaveProperty('timestamp');
                expect(response.role).toBe('assistant');
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should handle message with context', async () => {
            try {
                const context = { previousMessages: ['Hello'], includeHistory: true };
                const response = await adapter.sendMessage('Continue our discussion', context);

                expect(response).toHaveProperty('content');
                expect(response.role).toBe('assistant');
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should validate message input', async () => {
            try {
                // Test empty message
                await expect(adapter.sendMessage('')).rejects.toThrow('Invalid message: must be non-empty string');

                // Test null message
                await expect(adapter.sendMessage(null as any)).rejects.toThrow('Invalid message: must be non-empty string');

                // Test undefined message
                await expect(adapter.sendMessage(undefined as any)).rejects.toThrow('Invalid message: must be non-empty string');

                // Test non-string message
                await expect(adapter.sendMessage(123 as any)).rejects.toThrow('Invalid message: must be non-empty string');
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should handle extension not available during message sending', async () => {
            try {
                // Mock extension as not active
                const mockExtension = { isActive: false };
                (vscode.extensions.getExtension as jest.Mock).mockReturnValue(mockExtension);

                // Create new adapter with inactive extension
                const inactiveAdapter = new AuggieAdapter(mockConfig);

                await expect(inactiveAdapter.sendMessage('test')).rejects.toThrow('Augment Code extension not available or not active');
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should handle command execution failures with fallback', async () => {
            try {
                // Mock all commands to fail initially
                (vscode.commands.executeCommand as jest.Mock)
                    .mockRejectedValueOnce(new Error('Command 1 failed'))
                    .mockRejectedValueOnce(new Error('Command 2 failed'))
                    .mockResolvedValueOnce(undefined) // workbench.view.extension.augment
                    .mockResolvedValueOnce(undefined); // augment.openChat

                const response = await adapter.sendMessage('Hello Auggie');

                expect(response.content).toContain('Agent Processing Complete');
                expect(vscode.commands.executeCommand).toHaveBeenCalledWith('workbench.view.extension.augment');
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should handle clipboard fallback when all commands fail', async () => {
            try {
                // Mock all commands to fail
                (vscode.commands.executeCommand as jest.Mock).mockRejectedValue(new Error('All commands failed'));

                // Mock clipboard and user interaction
                const mockClipboard = { writeText: jest.fn().mockResolvedValue(undefined) };
                (vscode as any).env = { clipboard: mockClipboard };
                (vscode.window.showInformationMessage as jest.Mock).mockResolvedValue('Continue');

                const response = await adapter.sendMessage('Hello Auggie');

                expect(mockClipboard.writeText).toHaveBeenCalledWith('Hello Auggie');
                expect(response.content).toContain('Agent Request Prepared');
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should handle clipboard fallback with Open Augment Code action', async () => {
            try {
                // Mock all commands to fail
                (vscode.commands.executeCommand as jest.Mock).mockRejectedValue(new Error('All commands failed'));

                // Mock clipboard and user interaction
                const mockClipboard = { writeText: jest.fn().mockResolvedValue(undefined) };
                (vscode as any).env = { clipboard: mockClipboard };
                (vscode.window.showInformationMessage as jest.Mock).mockResolvedValue('Open Augment Code');

                const response = await adapter.sendMessage('Hello Auggie');

                expect(mockClipboard.writeText).toHaveBeenCalledWith('Hello Auggie');
                expect(response.content).toContain('Agent Request Prepared');
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should measure response time correctly', async () => {
            try {
                (vscode.commands.executeCommand as jest.Mock).mockResolvedValue('Quick response');

                const startTime = Date.now();
                const response = await adapter.sendMessage('Hello Auggie');
                const endTime = Date.now();

                expect(response.metadata?.responseTime).toBeGreaterThanOrEqual(0);
                expect(response.metadata?.responseTime).toBeLessThanOrEqual(endTime - startTime + 100); // Allow some margin
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should generate unique message IDs', async () => {
            try {
                (vscode.commands.executeCommand as jest.Mock).mockResolvedValue('Response 1');
                const response1 = await adapter.sendMessage('Message 1');

                (vscode.commands.executeCommand as jest.Mock).mockResolvedValue('Response 2');
                const response2 = await adapter.sendMessage('Message 2');

                expect(response1.id).not.toBe(response2.id);
                expect(response1.id).toMatch(/^auggie-\d+-[a-z0-9]+$/);
                expect(response2.id).toMatch(/^auggie-\d+-[a-z0-9]+$/);
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });
    });

    describe('Extension Detection and Initialization', () => {
        it('should try alternative extension IDs when primary not found', () => {
            try {
                // Mock primary extension not found, but alternative found
                (vscode.extensions.getExtension as jest.Mock)
                    .mockReturnValueOnce(undefined) // augment.vscode-augment
                    .mockReturnValueOnce({ id: 'Augment.vscode-augment', isActive: true }); // Alternative ID

                const newAdapter = new AuggieAdapter(mockConfig);
                expect(newAdapter).toBeInstanceOf(AuggieAdapter);
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should handle missing vscode.extensions gracefully', () => {
            try {
                // Temporarily remove vscode.extensions
                const originalExtensions = vscode.extensions;
                delete (vscode as any).extensions;

                expect(() => new AuggieAdapter(mockConfig)).toThrow('vscode.extensions.getExtension not available');

                // Restore
                (vscode as any).extensions = originalExtensions;
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });

        it('should log extension detection process', () => {
            try {
                const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

                new AuggieAdapter(mockConfig);

                expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('AuggieAdapter: Constructor called'));
                expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Config validation passed'));

                consoleSpy.mockRestore();
            } catch (error) {
                // MANDATORY: Comprehensive error handling
                console.error('Test failed:', error);
                throw error;
            }
        });
    });
});
