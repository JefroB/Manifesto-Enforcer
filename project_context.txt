Project Context: All TypeScript Files

==================== FILE: src/agents/adapters/AuggieAdapter.ts ====================
/**
 * Auggie (Augment Code) Agent Adapter
 * Following manifesto: interface-based programming, comprehensive error handling
 */

import * as vscode from 'vscode';
import { IAgentAdapter, AgentCapabilities } from '../interfaces/IAgentAdapter';
import { AgentConfig, ChatMessage, AgentProvider } from '../../core/types';

/**
 * Adapter for Auggie (Augment Code) integration
 * Implements secure communication with Augment Code extension
 */
export class AuggieAdapter implements IAgentAdapter {
  private config: AgentConfig;
  private augmentExtension: vscode.Extension<any> | undefined;

  constructor(config: AgentConfig) {
    console.log('üê∑ AuggieAdapter: Constructor called with config:', config);

    // MANDATORY: Input validation
    if (!config || config.provider !== AgentProvider.AUGGIE) {
      console.error('üê∑ AuggieAdapter: Invalid configuration:', config);
      throw new Error('Invalid configuration for Auggie adapter');
    }

    console.log('üê∑ AuggieAdapter: Config validation passed');
    this.config = { ...config };
    console.log('üê∑ AuggieAdapter: Config stored, initializing Augment extension...');
    this.initializeAugmentExtension();
    console.log('üê∑ AuggieAdapter: Constructor completed');
  }

  /**
   * Send message to Auggie
   * OPTIMIZE: Ensure sub-200ms response when possible
   */
  async sendMessage(message: string, context?: any): Promise<ChatMessage> {
    const startTime = Date.now();

    try {
      // MANDATORY: Input validation
      if (!message || typeof message !== 'string') {
        throw new Error('Invalid message: must be non-empty string');
      }

      // Check if Augment extension is available
      if (!this.augmentExtension || !this.augmentExtension.isActive) {
        throw new Error('Augment Code extension not available or not active');
      }

      // Try different methods to communicate with Augment
      const response = await this.sendToAugment(message, context);

      const duration = Date.now() - startTime;
      if (duration > 200) {
        console.warn(`Auggie response took ${duration}ms - exceeds performance target`);
      }

      return {
        id: this.generateMessageId(),
        role: 'assistant',
        content: response,
        timestamp: new Date(),
        agentId: this.config.id,
        metadata: {
          responseTime: duration,
          provider: 'auggie'
        }
      };

    } catch (error) {
      // MANDATORY: Comprehensive error handling
      const errorMessage = error instanceof Error ? error.message : 'Unknown Auggie error';
      throw new Error(`Auggie communication failed: ${errorMessage}`);
    }
  }

  /**
   * Validate connection to Augment Code
   * REQUIRED: Check if extension is available and active
   */
  async validateConnection(): Promise<boolean> {
    try {
      console.log('üê∑ AuggieAdapter: Starting connection validation...');

      // Try different possible extension IDs for Augment Code
      const possibleIds = [
        'augment.vscode-augment',
        'augment.augment',
        'augmentcode.augment',
        'Augment.augment'
      ];

      console.log('üê∑ AuggieAdapter: Checking for Augment extension with IDs:', possibleIds);

      for (const id of possibleIds) {
        this.augmentExtension = vscode.extensions.getExtension(id);
        if (this.augmentExtension) {
          console.log('üê∑ AuggieAdapter: Found Augment extension with ID:', id);
          console.log('üê∑ AuggieAdapter: Extension details:', {
            id: this.augmentExtension.id,
            isActive: this.augmentExtension.isActive,
            displayName: this.augmentExtension.packageJSON?.displayName,
            version: this.augmentExtension.packageJSON?.version
          });
          break;
        }
      }

      if (!this.augmentExtension) {
        console.warn('üê∑ AuggieAdapter: Augment Code extension not found with any known ID');
        console.log('üê∑ AuggieAdapter: Available extensions:', vscode.extensions.all.map(ext => ext.id).filter(id => id.toLowerCase().includes('augment')));
        return false;
      }

      // Activate if not already active (with timeout to prevent hanging)
      if (!this.augmentExtension.isActive) {
        console.log('üê∑ Activating Augment extension...');
        const activationPromise = this.augmentExtension.activate();
        const timeoutPromise = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Activation timeout - likely authentication needed')), 2000)
        );

        try {
          await Promise.race([activationPromise, timeoutPromise]);
          console.log('üê∑ Augment extension activated successfully');
        } catch (error) {
          console.warn('üê∑ Augment extension activation timed out - this usually means authentication is needed');

          // Show helpful message to user about authentication
          const authAction = await vscode.window.showInformationMessage(
            'üê∑ Piggie needs you to sign in to Augment Code first!',
            'Open Augment Panel',
            'Learn More'
          );

          if (authAction === 'Open Augment Panel') {
            // Try to open Augment panel for authentication
            try {
              await vscode.commands.executeCommand('workbench.view.extension.augment');
            } catch {
              await vscode.commands.executeCommand('augment.openPanel');
            }
          } else if (authAction === 'Learn More') {
            vscode.env.openExternal(vscode.Uri.parse('https://docs.augmentcode.com/setup-augment/sign-in'));
          }

          return false;
        }
      }

      // Test basic functionality
      const commands = await vscode.commands.getCommands();
      const hasAugmentCommands = commands.some(cmd => cmd.startsWith('augment.') || cmd.includes('chat'));

      return hasAugmentCommands;

    } catch (error) {
      console.error('Auggie validation failed:', error);
      return false;
    }
  }

  /**
   * Get adapter configuration
   * CRITICAL: Ensure sensitive data is handled securely
   */
  getConfig(): AgentConfig {
    // Return a copy to prevent external modification
    return { ...this.config };
  }

  /**
   * Get Auggie capabilities
   */
  getCapabilities(): AgentCapabilities {
    return {
      supportsCodeGeneration: true,
      supportsFileOperations: true,
      supportsStreaming: false, // Auggie doesn't support streaming yet
      maxTokens: 8192, // Estimated based on Auggie's capabilities
      supportedLanguages: [
        'typescript', 'javascript', 'python', 'java', 'csharp', 
        'cpp', 'rust', 'go', 'php', 'ruby', 'swift', 'kotlin'
      ],
      rateLimits: {
        requestsPerMinute: 60,
        tokensPerMinute: 100000,
        maxConcurrentRequests: 5
      }
    };
  }

  /**
   * Clean up resources
   * MANDATORY: Proper resource disposal
   */
  async dispose(): Promise<void> {
    try {
      // Clear any cached data
      this.augmentExtension = undefined;
      
      // Clear sensitive configuration
      if (this.config.apiKey) {
        this.config.apiKey = '';
      }

      console.log('Auggie adapter disposed successfully');

    } catch (error) {
      console.error('Error disposing Auggie adapter:', error);
    }
  }

  // Private helper methods

  private initializeAugmentExtension(): void {
    try {
      console.log('üê∑ AuggieAdapter: initializeAugmentExtension() called');
      console.log('üê∑ AuggieAdapter: Checking vscode.extensions availability...');
      console.log('üê∑ AuggieAdapter: vscode.extensions type:', typeof vscode.extensions);
      console.log('üê∑ AuggieAdapter: vscode.extensions.getExtension type:', typeof vscode.extensions?.getExtension);

      if (!vscode.extensions || !vscode.extensions.getExtension) {
        throw new Error('vscode.extensions.getExtension not available');
      }

      console.log('üê∑ AuggieAdapter: Attempting to get Augment extension...');
      this.augmentExtension = vscode.extensions.getExtension('augment.vscode-augment');

      if (this.augmentExtension) {
        console.log('üê∑ AuggieAdapter: Augment extension found:', {
          id: this.augmentExtension.id,
          isActive: this.augmentExtension.isActive,
          displayName: this.augmentExtension.packageJSON?.displayName
        });
      } else {
        console.log('üê∑ AuggieAdapter: Augment extension not found with ID "augment.vscode-augment"');
        console.log('üê∑ AuggieAdapter: Trying alternative extension IDs...');

        const alternativeIds = [
          'Augment.vscode-augment',
          'augment.augment',
          'Augment.augment'
        ];

        for (const id of alternativeIds) {
          console.log('üê∑ AuggieAdapter: Trying extension ID:', id);
          this.augmentExtension = vscode.extensions.getExtension(id);
          if (this.augmentExtension) {
            console.log('üê∑ AuggieAdapter: Found Augment extension with ID:', id);
            break;
          }
        }

        if (!this.augmentExtension) {
          console.log('üê∑ AuggieAdapter: No Augment extension found with any known ID');
        }
      }

    } catch (error) {
      console.warn('üê∑ AuggieAdapter: Could not initialize Augment extension:', error);
      console.log('üê∑ AuggieAdapter: Error details:', {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : 'No stack trace'
      });
    }
  }

  private async sendToAugment(message: string, context?: any): Promise<string> {
    try {
      // Method 1: Try direct API if available
      if (this.augmentExtension?.exports?.sendMessage) {
        return await this.augmentExtension.exports.sendMessage(message, context);
      }

      // Method 2: Try command execution with timeout
      const chatCommands = [
        'workbench.action.chat.open',
        'workbench.action.chat.toggle',
        'augment.openChat'
      ];

      for (const command of chatCommands) {
        try {
          // Add timeout to prevent hanging
          const commandPromise = vscode.commands.executeCommand(command);
          const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Command timeout')), 1000)
          );

          await Promise.race([commandPromise, timeoutPromise]);
          break;
        } catch (error) {
          console.log(`Command ${command} failed, trying next...`);
        }
      }

      // Method 3: Fallback to clipboard integration
      await vscode.env.clipboard.writeText(message);
      
      vscode.window.showInformationMessage(
        'ü§ñ Message ready for Auggie - paste in Augment Code chat',
        'Open Augment'
      );

      // Return a placeholder response since we can't get actual response
      return `Message sent to Auggie via clipboard. Please check Augment Code for response.`;

    } catch (error) {
      throw new Error(`Failed to communicate with Augment: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private generateMessageId(): string {
    return `auggie-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

==================== FILE: src/agents/AgentManager.ts ====================
/**
 * Agent Manager - Central hub for managing AI agents
 * Following manifesto: SOLID principles, dependency injection, comprehensive error handling
 */

import { IAgentAdapter, AgentCapabilities } from './interfaces/IAgentAdapter';
import { AgentConfig, ChatMessage, PerformanceMetrics } from '../core/types';

/**
 * Manages multiple AI agents with manifesto compliance
 * Implements dependency injection and interface-based programming
 */
export class AgentManager {
  private agents: Map<string, IAgentAdapter> = new Map();
  private activeAgentId: string | null = null;
  private performanceMetrics: PerformanceMetrics[] = [];

  /**
   * Register a new AI agent adapter
   * MANDATORY: Validate agent before registration
   * CRITICAL: Handle sensitive configuration securely
   */
  async registerAgent(adapter: IAgentAdapter): Promise<void> {
    try {
      // MANDATORY: Input validation (manifesto requirement)
      if (!adapter) {
        throw new Error('Invalid agent adapter: adapter cannot be null or undefined');
      }

      const config = adapter.getConfig();
      if (!config || !config.id || !config.name) {
        throw new Error('Invalid agent configuration: missing required fields');
      }

      // REQUIRED: Validate agent connection
      const isValid = await adapter.validateConnection();
      if (!isValid) {
        throw new Error('Agent validation failed: unable to establish connection');
      }

      // Register the agent
      this.agents.set(config.id, adapter);

      // Set as active if it's the first agent
      if (this.agents.size === 1) {
        this.activeAgentId = config.id;
      }

      console.log(`Agent registered successfully: ${config.name} (${config.id})`);

    } catch (error) {
      // MANDATORY: Comprehensive error handling
      const errorMessage = error instanceof Error ? error.message : 'Unknown registration error';
      throw new Error(`Failed to register agent: ${errorMessage}`);
    }
  }

  /**
   * Send message to active agent with manifesto compliance
   * OPTIMIZE: Monitor performance and ensure sub-200ms when possible
   */
  async sendMessage(message: string, manifestoApplied: boolean = false): Promise<ChatMessage> {
    const startTime = Date.now();

    try {
      // MANDATORY: Input validation
      if (!message || typeof message !== 'string' || message.trim().length === 0) {
        throw new Error('Invalid message content: message must be a non-empty string');
      }

      // Check for active agent
      if (!this.activeAgentId || !this.agents.has(this.activeAgentId)) {
        throw new Error('No active agent available: please select an agent first');
      }

      const activeAgent = this.agents.get(this.activeAgentId)!;
      
      // Send message to agent
      const response = await activeAgent.sendMessage(message);

      // Add metadata
      response.manifestoApplied = manifestoApplied;
      response.agentId = this.activeAgentId;

      // OPTIMIZE: Record performance metrics (manifesto requirement)
      const duration = Date.now() - startTime;
      this.recordPerformanceMetric('sendMessage', duration);

      if (duration > 200) {
        console.warn(`Message processing took ${duration}ms - exceeds 200ms performance target`);
      }

      return response;

    } catch (error) {
      // MANDATORY: Comprehensive error handling
      const errorMessage = error instanceof Error ? error.message : 'Unknown messaging error';
      throw new Error(`Failed to send message: ${errorMessage}`);
    }
  }

  /**
   * Switch active agent
   * REQUIRED: Validate agent exists before switching
   */
  setActiveAgent(agentId: string): void {
    try {
      if (!agentId || typeof agentId !== 'string') {
        throw new Error('Invalid agent ID: must be a non-empty string');
      }

      if (!this.agents.has(agentId)) {
        throw new Error(`Agent not found: ${agentId}`);
      }

      this.activeAgentId = agentId;
      console.log(`Switched to agent: ${agentId}`);

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown switching error';
      throw new Error(`Failed to switch agent: ${errorMessage}`);
    }
  }

  /**
   * Get currently active agent
   */
  getActiveAgent(): AgentConfig | null {
    if (!this.activeAgentId || !this.agents.has(this.activeAgentId)) {
      return null;
    }

    return this.agents.get(this.activeAgentId)!.getConfig();
  }

  /**
   * Get all available agents
   */
  getAvailableAgents(): AgentConfig[] {
    return Array.from(this.agents.values()).map(adapter => adapter.getConfig());
  }

  /**
   * Get agent capabilities
   */
  getAgentCapabilities(agentId: string): AgentCapabilities | null {
    const agent = this.agents.get(agentId);
    if (!agent || !agent.getCapabilities) {
      return null;
    }

    return agent.getCapabilities();
  }

  /**
   * Remove agent
   * MANDATORY: Proper cleanup and resource disposal
   */
  async removeAgent(agentId: string): Promise<void> {
    try {
      const agent = this.agents.get(agentId);
      if (!agent) {
        throw new Error(`Agent not found: ${agentId}`);
      }

      // Clean up agent resources
      await agent.dispose();

      // Remove from registry
      this.agents.delete(agentId);

      // Update active agent if necessary
      if (this.activeAgentId === agentId) {
        const remainingAgents = Array.from(this.agents.keys());
        this.activeAgentId = remainingAgents.length > 0 ? remainingAgents[0] : null;
      }

      console.log(`Agent removed: ${agentId}`);

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown removal error';
      throw new Error(`Failed to remove agent: ${errorMessage}`);
    }
  }

  /**
   * Get performance metrics
   * OPTIMIZE: Monitor system performance as per manifesto
   */
  getPerformanceMetrics(): PerformanceMetrics[] {
    return [...this.performanceMetrics];
  }

  /**
   * Dispose all agents and clean up resources
   * MANDATORY: Comprehensive cleanup
   */
  async dispose(): Promise<void> {
    try {
      const disposePromises = Array.from(this.agents.values()).map(agent => agent.dispose());
      await Promise.all(disposePromises);

      this.agents.clear();
      this.activeAgentId = null;
      this.performanceMetrics = [];

      console.log('AgentManager disposed successfully');

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown disposal error';
      throw new Error(`Failed to dispose AgentManager: ${errorMessage}`);
    }
  }

  // Private helper methods

  private recordPerformanceMetric(operation: string, duration: number): void {
    this.performanceMetrics.push({
      responseTime: duration,
      memoryUsage: process.memoryUsage().heapUsed,
      timestamp: new Date()
    });

    // Keep only last 100 metrics to prevent memory leaks
    if (this.performanceMetrics.length > 100) {
      this.performanceMetrics = this.performanceMetrics.slice(-100);
    }
  }
}

==================== FILE: src/agents/interfaces/IAgentAdapter.ts ====================
/**
 * Agent Adapter Interface
 * Following manifesto: interface-based programming, clear separation of concerns
 */

import { AgentConfig, ChatMessage } from '../../core/types';

/**
 * Interface for all AI agent adapters
 * Ensures consistent behavior across different AI providers
 */
export interface IAgentAdapter {
  /**
   * Send message to the AI agent
   * OPTIMIZE: Must complete under 200ms when possible
   * MANDATORY: Include comprehensive error handling
   */
  sendMessage(message: string, context?: any): Promise<ChatMessage>;

  /**
   * Validate connection to the AI service
   * REQUIRED: Check authentication and service availability
   */
  validateConnection(): Promise<boolean>;

  /**
   * Get agent configuration
   * CRITICAL: Ensure sensitive data is encrypted
   */
  getConfig(): AgentConfig;

  /**
   * Clean up resources
   * MANDATORY: Proper resource disposal
   */
  dispose(): Promise<void>;

  /**
   * Get agent capabilities and limitations
   */
  getCapabilities?(): AgentCapabilities;

  /**
   * Handle streaming responses (optional)
   */
  sendStreamingMessage?(message: string, onChunk: (chunk: string) => void): Promise<void>;
}

/**
 * Agent capabilities definition
 */
export interface AgentCapabilities {
  supportsCodeGeneration: boolean;
  supportsFileOperations: boolean;
  supportsStreaming: boolean;
  maxTokens: number;
  supportedLanguages: string[];
  rateLimits: RateLimits;
}

/**
 * Rate limiting configuration
 */
export interface RateLimits {
  requestsPerMinute: number;
  tokensPerMinute: number;
  maxConcurrentRequests: number;
}

==================== FILE: src/agents/__tests__/AgentManager.test.ts ====================
/**
 * Test suite for AgentManager
 * Following manifesto: comprehensive unit tests, interface-based programming
 */

import { AgentManager } from '../AgentManager';
import { IAgentAdapter } from '../interfaces/IAgentAdapter';
import { AgentProvider, AgentConfig, ChatMessage } from '../../core/types';

// Mock agent adapter for testing
class MockAgentAdapter implements IAgentAdapter {
  constructor(private config: AgentConfig) {}

  async sendMessage(message: string): Promise<ChatMessage> {
    return {
      id: 'test-response',
      role: 'assistant',
      content: `Mock response to: ${message}`,
      timestamp: new Date(),
      agentId: this.config.id
    };
  }

  async validateConnection(): Promise<boolean> {
    return this.config.isEnabled;
  }

  getConfig(): AgentConfig {
    return this.config;
  }

  async dispose(): Promise<void> {
    // Mock cleanup
  }

  getCapabilities() {
    return {
      supportsCodeGeneration: true,
      supportsFileOperations: true,
      supportsStreaming: false,
      maxTokens: 4096,
      supportedLanguages: ['typescript', 'javascript'],
      rateLimits: {
        requestsPerMinute: 60,
        tokensPerMinute: 100000,
        maxConcurrentRequests: 5
      }
    };
  }
}

describe('AgentManager', () => {
  let agentManager: AgentManager;
  let mockConfig: AgentConfig;

  beforeEach(() => {
    agentManager = new AgentManager();
    mockConfig = {
      id: 'test-agent',
      name: 'Test Agent',
      provider: AgentProvider.AUGGIE,
      isEnabled: true,
      apiKey: 'test-key'
    };
  });

  describe('registerAgent', () => {
    it('should register agent successfully', async () => {
      const adapter = new MockAgentAdapter(mockConfig);
      
      await agentManager.registerAgent(adapter);
      
      const registeredAgents = agentManager.getAvailableAgents();
      expect(registeredAgents).toHaveLength(1);
      expect(registeredAgents[0].id).toBe('test-agent');
    });

    it('should validate agent before registration', async () => {
      const invalidConfig = { ...mockConfig, isEnabled: false };
      const adapter = new MockAgentAdapter(invalidConfig);

      await expect(agentManager.registerAgent(adapter))
        .rejects.toThrow('Agent validation failed: unable to establish connection');
    });

    it('should handle registration errors gracefully', async () => {
      const nullAdapter = null as any;
      
      await expect(agentManager.registerAgent(nullAdapter))
        .rejects.toThrow('Invalid agent adapter');
    });
  });

  describe('sendMessage', () => {
    beforeEach(async () => {
      const adapter = new MockAgentAdapter(mockConfig);
      await agentManager.registerAgent(adapter);
      agentManager.setActiveAgent('test-agent');
    });

    it('should send message to active agent', async () => {
      const response = await agentManager.sendMessage('Hello, agent!');
      
      expect(response.content).toContain('Mock response to: Hello, agent!');
      expect(response.agentId).toBe('test-agent');
      expect(response.role).toBe('assistant');
    });

    it('should handle missing active agent', async () => {
      // Try to set non-existent agent - should throw error
      try {
        await agentManager.setActiveAgent('non-existent');
        fail('Should have thrown error');
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
        expect((error as Error).message).toContain('Agent not found');
      }
    });

    it('should validate message input', async () => {
      await expect(agentManager.sendMessage(''))
        .rejects.toThrow('Invalid message content');
      
      await expect(agentManager.sendMessage(null as any))
        .rejects.toThrow('Invalid message content');
    });

    it('should complete within performance requirements', async () => {
      const startTime = Date.now();
      
      await agentManager.sendMessage('Performance test');
      
      const duration = Date.now() - startTime;
      expect(duration).toBeLessThan(200); // Manifesto requirement
    });
  });

  describe('switchAgent', () => {
    it('should switch between registered agents', async () => {
      const agent1 = new MockAgentAdapter(mockConfig);
      const agent2Config = { ...mockConfig, id: 'agent-2', name: 'Agent 2' };
      const agent2 = new MockAgentAdapter(agent2Config);
      
      await agentManager.registerAgent(agent1);
      await agentManager.registerAgent(agent2);
      
      agentManager.setActiveAgent('test-agent');
      expect(agentManager.getActiveAgent()?.id).toBe('test-agent');
      
      agentManager.setActiveAgent('agent-2');
      expect(agentManager.getActiveAgent()?.id).toBe('agent-2');
    });

    it('should handle invalid agent switching', () => {
      expect(() => agentManager.setActiveAgent('non-existent'))
        .toThrow('Agent not found: non-existent');
    });
  });

  describe('getAgentCapabilities', () => {
    it('should return agent capabilities', async () => {
      const adapter = new MockAgentAdapter(mockConfig);
      await agentManager.registerAgent(adapter);
      
      const capabilities = agentManager.getAgentCapabilities('test-agent');

      expect(capabilities).toBeDefined();
      expect(capabilities?.supportsCodeGeneration).toBe(true);
    });

    it('should handle missing agent gracefully', () => {
      const capabilities = agentManager.getAgentCapabilities('non-existent');
      expect(capabilities).toBeNull();
    });
  });

  describe('error handling and security', () => {
    it('should encrypt sensitive configuration data', async () => {
      const sensitiveConfig = {
        ...mockConfig,
        apiKey: 'super-secret-key'
      };
      
      const adapter = new MockAgentAdapter(sensitiveConfig);
      await agentManager.registerAgent(adapter);
      
      // Verify that sensitive data is handled securely
      const storedConfig = agentManager.getActiveAgent();
      expect(storedConfig?.apiKey).toBeDefined();
      // In real implementation, this would be encrypted
    });

    it('should handle network timeouts gracefully', async () => {
      // Create a proper mock adapter with all required methods
      const timeoutAdapter = new MockAgentAdapter(mockConfig);
      timeoutAdapter.sendMessage = jest.fn().mockImplementation(() =>
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Network timeout')), 100)
        )
      );

      await agentManager.registerAgent(timeoutAdapter);
      agentManager.setActiveAgent('test-agent');

      await expect(agentManager.sendMessage('test'))
        .rejects.toThrow('Network timeout');
    });
  });
});

==================== FILE: src/commands/ChatCommandManager.ts ====================
import { IChatCommand } from './IChatCommand';
import { StateManager } from '../core/StateManager';
import { LintCommand } from './LintCommand';
import { EditCommand } from './EditCommand';
import { GraphCommand } from './GraphCommand';
import { GlossaryCommand } from './GlossaryCommand';
import { ManifestoCommand } from './ManifestoCommand';
import { CodeCommand } from './CodeCommand';
import { GeneralHelpCommand } from './GeneralHelpCommand';

/**
 * Central manager for all chat commands using the Command Pattern
 * This class replaces the large if/else if block in generateManifestoCompliantResponse
 */
export class ChatCommandManager {
    private commands: IChatCommand[] = [];

    /**
     * Initialize the command manager with all available commands
     */
    constructor() {
        this.initializeCommands();
    }

    /**
     * Initialize all command instances
     * GeneralHelpCommand is added last as it always handles input (fallback)
     */
    private initializeCommands(): void {
        this.commands = [
            new LintCommand(),
            new EditCommand(),
            new GraphCommand(),
            new GlossaryCommand(),
            new ManifestoCommand(),
            new CodeCommand(),
            new GeneralHelpCommand() // Always last - serves as fallback
        ];
    }

    /**
     * Handle a user message by finding the appropriate command and executing it
     * @param input - The user's input message
     * @param stateManager - The state manager instance
     * @returns Promise resolving to the response message
     */
    async handleMessage(input: string, stateManager: StateManager): Promise<string> {
        try {
            // Find the first command that can handle this input
            // Since GeneralHelpCommand is last and always returns true, a command will always be found
            const command = this.findMatchingCommand(input);

            console.log(`üéØ Command matched: ${command!.constructor.name} for input: "${input.substring(0, 50)}..."`);
            return await command!.execute(input, stateManager);

        } catch (error) {
            console.error('ChatCommandManager error:', error);
            return `‚ùå Command execution failed: ${error instanceof Error ? error.message : String(error)}`;
        }
    }

    /**
     * Find the first command that can handle the given input
     * @param input - The user's input message
     * @returns The matching command or null if none found
     */
    private findMatchingCommand(input: string): IChatCommand | null {
        for (const command of this.commands) {
            if (command.canHandle(input)) {
                return command;
            }
        }
        return null;
    }



    /**
     * Get a list of all available commands for debugging/info purposes
     */
    getAvailableCommands(): string[] {
        return this.commands.map(cmd => cmd.command);
    }

    /**
     * Get command statistics for monitoring
     */
    getCommandStats(): { [key: string]: string } {
        const stats: { [key: string]: string } = {};
        
        this.commands.forEach(cmd => {
            stats[cmd.constructor.name] = cmd.command;
        });

        return stats;
    }

    /**
     * Add a new command dynamically (for extensibility)
     */
    addCommand(command: IChatCommand): void {
        this.commands.push(command);
        console.log(`‚ûï Added new command: ${command.constructor.name} (${command.command})`);
    }

    /**
     * Remove a command by its class name
     */
    removeCommand(commandClassName: string): boolean {
        const initialLength = this.commands.length;
        this.commands = this.commands.filter(cmd => cmd.constructor.name !== commandClassName);
        
        const removed = this.commands.length < initialLength;
        if (removed) {
            console.log(`‚ûñ Removed command: ${commandClassName}`);
        }
        
        return removed;
    }

    /**
     * Test if a specific input would match any command (for debugging)
     */
    testInput(input: string): { matched: boolean; commandName?: string; command?: string } {
        const command = this.findMatchingCommand(input);
        
        if (command) {
            return {
                matched: true,
                commandName: command.constructor.name,
                command: command.command
            };
        }
        
        return { matched: false };
    }
}

==================== FILE: src/commands/CodeCommand.ts ====================
import { IChatCommand } from './IChatCommand';
import { StateManager } from '../core/StateManager';

/**
 * Command for handling code generation and creation requests
 * Handles patterns like "write", "create", "generate", "build", "make", "code", "function", "class", "component"
 */
export class CodeCommand implements IChatCommand {
    public readonly command = '/code';

    /**
     * Determines if this command can handle the given input
     */
    canHandle(input: string): boolean {
        // Handle code generation requests
        if (/\b(write|create|generate|build|make|code|function|class|component|hello world|script)\b/i.test(input)) {
            return true;
        }

        return false;
    }

    /**
     * Executes the code command
     */
    async execute(input: string, stateManager: StateManager): Promise<string> {
        try {
            // Check for specific code patterns
            if (/hello world/i.test(input)) {
                return await this.handleHelloWorldRequest(input, stateManager);
            }

            if (/\b(component|react)\b/i.test(input)) {
                return await this.handleComponentRequest(input, stateManager);
            }

            if (/\b(function|method)\b/i.test(input)) {
                return await this.handleFunctionRequest(input, stateManager);
            }

            if (/\b(class|service)\b/i.test(input)) {
                return await this.handleClassRequest(input, stateManager);
            }

            if (/\b(api|endpoint)\b/i.test(input)) {
                return await this.handleAPIRequest(input, stateManager);
            }

            // General code generation
            return await this.handleGeneralCodeRequest(input, stateManager);

        } catch (error) {
            return `‚ùå Code generation failed: ${error instanceof Error ? error.message : String(error)}`;
        }
    }

    /**
     * Handle Hello World requests
     */
    private async handleHelloWorldRequest(input: string, stateManager: StateManager): Promise<string> {
        if (stateManager.isManifestoMode) {
            // Manifesto Mode: Full compliance features
            const helloWorldCode = `// Hello World with manifesto compliance
console.log("Hello, World!");

// Additional manifesto-compliant features
function greet(name = "World") {
    try {
        if (!name || typeof name !== 'string') {
            throw new Error('Invalid name parameter');
        }
        return \`Hello, \${name}!\`;
    } catch (error) {
        console.error('Greeting error:', error);
        return 'Hello, World!';
    }
}

console.log(greet());
console.log(greet("Developer"));`;

            let response = `üéâ **Hello World Script Ready!**\n\n`;
            response += `**Manifesto-compliant features:**\n`;
            response += `‚Ä¢ ‚úÖ Comprehensive error handling\n`;
            response += `‚Ä¢ ‚úÖ Input validation\n`;
            response += `‚Ä¢ ‚úÖ Proper logging\n`;
            response += `‚Ä¢ ‚úÖ JSDoc-ready structure\n\n`;

            response += `**Code:**\n\`\`\`javascript\n${helloWorldCode}\n\`\`\`\n\n`;

            response += `**Next Steps:**\n`;
            response += `‚Ä¢ Copy the code to create hello-world.js\n`;
            response += `‚Ä¢ Run with: \`node hello-world.js\`\n`;
            response += `‚Ä¢ Extend with additional functionality as needed`;

            return response;
        } else {
            // Free Mode: Simple, direct code
            const simpleCode = `console.log("Hello, World!");`;

            let response = `üëã **Hello World**\n\n`;
            response += `**Code:**\n\`\`\`javascript\n${simpleCode}\n\`\`\`\n\n`;
            response += `Run with: \`node hello-world.js\``;

            return response;
        }
    }

    /**
     * Handle React component requests
     */
    private async handleComponentRequest(input: string, stateManager: StateManager): Promise<string> {
        const componentName = this.extractComponentName(input) || 'NewComponent';
        const relevantRules = this.getRelevantManifestoRules(input);

        const componentCode = `import React from 'react';

interface ${componentName}Props {
  // TODO: Define props based on requirements
}

/**
 * ${componentName} component
 * Manifesto compliance: ${relevantRules}
 */
export const ${componentName}: React.FC<${componentName}Props> = (props) => {
  try {
    // TODO: Implement component logic
    return (
      <div>
        <h1>${componentName}</h1>
        {/* TODO: Add component content */}
      </div>
    );
  } catch (error) {
    console.error('${componentName} error:', error);
    return <div>Error loading component</div>;
  }
};

export default ${componentName};`;

        let response = `‚öõÔ∏è **React Component Generated: ${componentName}**\n\n`;
        response += `**Manifesto Features:**\n`;
        response += `‚Ä¢ ‚úÖ TypeScript interfaces\n`;
        response += `‚Ä¢ ‚úÖ Error boundary pattern\n`;
        response += `‚Ä¢ ‚úÖ JSDoc documentation\n`;
        response += `‚Ä¢ ‚úÖ Proper error handling\n\n`;

        response += `**Code:**\n\`\`\`typescript\n${componentCode}\n\`\`\`\n\n`;

        response += `**Next Steps:**\n`;
        response += `‚Ä¢ Save as \`${componentName}.tsx\`\n`;
        response += `‚Ä¢ Define props interface\n`;
        response += `‚Ä¢ Implement component logic\n`;
        response += `‚Ä¢ Add unit tests`;

        return response;
    }

    /**
     * Handle function creation requests
     */
    private async handleFunctionRequest(input: string, stateManager: StateManager): Promise<string> {
        const functionName = this.extractFunctionName(input) || 'newFunction';
        const relevantRules = this.getRelevantManifestoRules(input);

        const functionCode = `/**
 * ${functionName} - TODO: Add description
 * Manifesto compliance: ${relevantRules}
 * @param {any} input - Input parameter
 * @returns {Promise<any>} Result
 */
async function ${functionName}(input) {
    try {
        // Input validation
        if (!input) {
            throw new Error('Input is required');
        }

        // TODO: Implement function logic
        const result = processInput(input);
        
        return { success: true, data: result };

    } catch (error) {
        console.error(\`\${${functionName}.name} error:\`, error);
        throw new Error(\`Operation failed: \${error.message}\`);
    }
}

/**
 * Helper function for processing input
 * @param {any} input - Input to process
 * @returns {any} Processed result
 */
function processInput(input) {
    // TODO: Implement processing logic
    return input;
}

module.exports = { ${functionName} };`;

        let response = `üîß **Function Generated: ${functionName}**\n\n`;
        response += `**Manifesto Features:**\n`;
        response += `‚Ä¢ ‚úÖ Comprehensive error handling\n`;
        response += `‚Ä¢ ‚úÖ Input validation\n`;
        response += `‚Ä¢ ‚úÖ JSDoc documentation\n`;
        response += `‚Ä¢ ‚úÖ Proper logging\n`;
        response += `‚Ä¢ ‚úÖ Helper function separation\n\n`;

        response += `**Code:**\n\`\`\`javascript\n${functionCode}\n\`\`\`\n\n`;

        response += `**Next Steps:**\n`;
        response += `‚Ä¢ Implement the actual logic\n`;
        response += `‚Ä¢ Add specific input validation\n`;
        response += `‚Ä¢ Write unit tests\n`;
        response += `‚Ä¢ Update JSDoc with specific parameters`;

        return response;
    }

    /**
     * Handle class/service creation requests
     */
    private async handleClassRequest(input: string, stateManager: StateManager): Promise<string> {
        const className = this.extractClassName(input) || 'NewService';
        const relevantRules = this.getRelevantManifestoRules(input);

        const classCode = `/**
 * ${className} - TODO: Add description
 * Manifesto compliance: ${relevantRules}
 */
export interface I${className} {
    // TODO: Define interface methods
    execute(): Promise<void>;
}

export class ${className} implements I${className} {
    /**
     * Constructor with dependency injection
     */
    constructor() {
        // TODO: Initialize dependencies
    }

    /**
     * Main service method with comprehensive error handling
     * @returns {Promise<void>}
     */
    async execute(): Promise<void> {
        try {
            // TODO: Implement service logic
            await this.validateInputs();
            await this.performOperation();
            
        } catch (error) {
            console.error(\`\${${className}.name} execution error:\`, error);
            throw new Error(\`Service failed: \${error instanceof Error ? error.message : 'Unknown error'}\`);
        }
    }

    /**
     * Validate inputs before processing
     * @private
     */
    private async validateInputs(): Promise<void> {
        // TODO: Add input validation logic
    }

    /**
     * Perform the main operation
     * @private
     */
    private async performOperation(): Promise<void> {
        // TODO: Implement main operation logic
    }
}`;

        let response = `üèóÔ∏è **Class Generated: ${className}**\n\n`;
        response += `**Manifesto Features:**\n`;
        response += `‚Ä¢ ‚úÖ Interface-based programming\n`;
        response += `‚Ä¢ ‚úÖ Dependency injection ready\n`;
        response += `‚Ä¢ ‚úÖ Comprehensive error handling\n`;
        response += `‚Ä¢ ‚úÖ Input validation\n`;
        response += `‚Ä¢ ‚úÖ Separation of concerns\n`;
        response += `‚Ä¢ ‚úÖ JSDoc documentation\n\n`;

        response += `**Code:**\n\`\`\`typescript\n${classCode}\n\`\`\`\n\n`;

        response += `**Next Steps:**\n`;
        response += `‚Ä¢ Define interface methods\n`;
        response += `‚Ä¢ Implement constructor dependencies\n`;
        response += `‚Ä¢ Add specific validation logic\n`;
        response += `‚Ä¢ Write comprehensive tests`;

        return response;
    }

    /**
     * Handle API endpoint creation requests
     */
    private async handleAPIRequest(input: string, stateManager: StateManager): Promise<string> {
        const endpointName = this.extractEndpointName(input) || 'newEndpoint';
        const relevantRules = this.getRelevantManifestoRules(input);

        const apiCode = `import express from 'express';
import { Request, Response } from 'express';

/**
 * ${endpointName} API endpoint
 * Manifesto compliance: ${relevantRules}
 */

/**
 * Handle ${endpointName} request
 * @param req - Express request object
 * @param res - Express response object
 */
export async function handle${endpointName.charAt(0).toUpperCase() + endpointName.slice(1)}(req: Request, res: Response): Promise<void> {
    try {
        // Input validation
        const validationResult = validateRequest(req);
        if (!validationResult.isValid) {
            res.status(400).json({
                error: 'Invalid request',
                details: validationResult.errors
            });
            return;
        }

        // Process request
        const result = await processRequest(req.body);

        // Return success response
        res.status(200).json({
            success: true,
            data: result,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error(\`\${handle${endpointName.charAt(0).toUpperCase() + endpointName.slice(1)}.name} error:\`, error);
        
        res.status(500).json({
            error: 'Internal server error',
            message: error instanceof Error ? error.message : 'Unknown error',
            timestamp: new Date().toISOString()
        });
    }
}

/**
 * Validate incoming request
 * @param req - Express request object
 * @returns Validation result
 */
function validateRequest(req: Request): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // TODO: Add specific validation rules
    if (!req.body) {
        errors.push('Request body is required');
    }

    return {
        isValid: errors.length === 0,
        errors
    };
}

/**
 * Process the validated request
 * @param data - Request data
 * @returns Processing result
 */
async function processRequest(data: any): Promise<any> {
    // TODO: Implement business logic
    return { processed: true, data };
}`;

        let response = `üåê **API Endpoint Generated: ${endpointName}**\n\n`;
        response += `**Manifesto Features:**\n`;
        response += `‚Ä¢ ‚úÖ Comprehensive error handling\n`;
        response += `‚Ä¢ ‚úÖ Input validation\n`;
        response += `‚Ä¢ ‚úÖ Consistent response format\n`;
        response += `‚Ä¢ ‚úÖ Proper HTTP status codes\n`;
        response += `‚Ä¢ ‚úÖ TypeScript interfaces\n`;
        response += `‚Ä¢ ‚úÖ Separation of concerns\n\n`;

        response += `**Code:**\n\`\`\`typescript\n${apiCode}\n\`\`\`\n\n`;

        response += `**Next Steps:**\n`;
        response += `‚Ä¢ Add to Express router\n`;
        response += `‚Ä¢ Implement validation rules\n`;
        response += `‚Ä¢ Add business logic\n`;
        response += `‚Ä¢ Write API tests\n`;
        response += `‚Ä¢ Add rate limiting`;

        return response;
    }

    /**
     * Handle general code generation requests
     */
    private async handleGeneralCodeRequest(input: string, stateManager: StateManager): Promise<string> {
        if (stateManager.isManifestoMode) {
            // Manifesto Mode: Emphasize compliance
            const relevantRules = this.getRelevantManifestoRules(input);

            let response = `üíª **Ready to create manifesto-compliant code!**\n\n`;
            response += `**Request:** ${input}\n`;
            response += `**Applicable Rules:** ${relevantRules}\n\n`;

            if (stateManager.isCodebaseIndexed) {
                response += `**Context-Aware Generation:**\n`;
                response += `‚Ä¢ üìñ I'll analyze your existing codebase patterns\n`;
                response += `‚Ä¢ üîó I'll understand your imports and dependencies\n`;
                response += `‚Ä¢ üéØ I'll match your coding style and conventions\n`;
                response += `‚Ä¢ üõ°Ô∏è I'll apply manifesto compliance automatically\n\n`;
            } else {
                response += `**Standard Generation:**\n`;
                response += `‚Ä¢ üõ°Ô∏è Manifesto-compliant structure\n`;
                response += `‚Ä¢ ‚úÖ Error handling and validation\n`;
                response += `‚Ä¢ üìö JSDoc documentation\n`;
                response += `‚Ä¢ üß™ Test-ready code\n\n`;
                response += `üí° **Tip:** Index your codebase for smarter, context-aware code generation!\n\n`;
            }

            response += `**I can create:**\n`;
            response += `‚Ä¢ Functions with error handling\n`;
            response += `‚Ä¢ Classes with interfaces\n`;
            response += `‚Ä¢ React components\n`;
            response += `‚Ä¢ API endpoints\n`;
            response += `‚Ä¢ Service classes\n`;
            response += `‚Ä¢ Utility modules\n\n`;

            response += `**Be more specific:** "Create a UserService class" or "Generate a login API endpoint"`;

            return response;
        } else {
            // Free Mode: Simple, direct approach
            let response = `üíª **Ready to create code!**\n\n`;
            response += `**Request:** ${input}\n\n`;

            if (stateManager.isCodebaseIndexed) {
                response += `**Context-Aware Generation:**\n`;
                response += `‚Ä¢ üìñ I'll analyze your existing codebase patterns\n`;
                response += `‚Ä¢ üîó I'll understand your imports and dependencies\n`;
                response += `‚Ä¢ üéØ I'll match your coding style and conventions\n\n`;
            } else {
                response += `**Standard Generation:**\n`;
                response += `‚Ä¢ üöÄ Quick and simple code\n`;
                response += `‚Ä¢ üìù Clean structure\n`;
                response += `‚Ä¢ üéØ Focused on your request\n\n`;
                response += `üí° **Tip:** Index your codebase for smarter, context-aware code generation!\n\n`;
            }

            response += `**I can create:**\n`;
            response += `‚Ä¢ Functions\n`;
            response += `‚Ä¢ Classes\n`;
            response += `‚Ä¢ React components\n`;
            response += `‚Ä¢ API endpoints\n`;
            response += `‚Ä¢ Service classes\n`;
            response += `‚Ä¢ Utility modules\n\n`;

            response += `**Be more specific:** "Create a UserService class" or "Generate a login API endpoint"`;

            return response;
        }
    }

    /**
     * Extract component name from input
     */
    private extractComponentName(input: string): string | null {
        const match = input.match(/(?:component|create|generate)\s+(\w+)/i);
        return match ? match[1] : null;
    }

    /**
     * Extract function name from input
     */
    private extractFunctionName(input: string): string | null {
        const match = input.match(/(?:function|create|generate)\s+(\w+)/i);
        return match ? match[1] : null;
    }

    /**
     * Extract class name from input
     */
    private extractClassName(input: string): string | null {
        const match = input.match(/(?:class|service|create|generate)\s+(\w+)/i);
        return match ? match[1] : null;
    }

    /**
     * Extract endpoint name from input
     */
    private extractEndpointName(input: string): string | null {
        const match = input.match(/(?:api|endpoint|create|generate)\s+(\w+)/i);
        return match ? match[1] : null;
    }

    /**
     * Get relevant manifesto rules based on input
     */
    private getRelevantManifestoRules(input: string): string {
        const rules: string[] = [];
        const lowerInput = input.toLowerCase();

        if (lowerInput.includes('error') || lowerInput.includes('exception')) {
            rules.push('comprehensive error handling');
        }
        if (lowerInput.includes('api') || lowerInput.includes('endpoint')) {
            rules.push('<200ms response times');
        }
        if (lowerInput.includes('security') || lowerInput.includes('auth')) {
            rules.push('input validation & security');
        }
        if (lowerInput.includes('test') || lowerInput.includes('testing')) {
            rules.push('unit tests required');
        }

        // Always include core rules
        if (rules.length === 0) {
            return 'error handling, input validation, JSDoc documentation';
        }

        return rules.join(', ');
    }
}

==================== FILE: src/commands/EditCommand.ts ====================
import { IChatCommand } from './IChatCommand';
import { StateManager } from '../core/StateManager';

/**
 * Command for handling edit and modification requests
 * Handles patterns like "/edit", "modify", "update", "change", "fix", "add to"
 */
export class EditCommand implements IChatCommand {
    public readonly command = '/edit';

    /**
     * Determines if this command can handle the given input
     */
    canHandle(input: string): boolean {
        const trimmedInput = input.trim();
        
        // Handle slash commands
        if (/^\/edit\b/i.test(trimmedInput)) {
            return true;
        }

        // Handle natural language edit requests
        if (/\b(edit|modify|update|change|fix|add to)\b/i.test(input)) {
            return true;
        }

        return false;
    }

    /**
     * Executes the edit command
     */
    async execute(input: string, stateManager: StateManager): Promise<string> {
        try {
            if (!stateManager.isCodebaseIndexed) {
                return `‚ö†Ô∏è **Codebase not indexed yet!**\n\nI need to analyze your codebase first for smart editing capabilities.\n\nPlease click "üìö Index Codebase" first, then try again.`;
            }

            // Extract file name if mentioned
            const fileMatch = input.match(/(\w+\.(ts|js|tsx|jsx|py|java|cs|cpp|h|md|json))/i);
            if (fileMatch) {
                return await this.handleFileEdit(fileMatch[1], input, stateManager);
            }

            // General edit guidance
            return this.provideEditGuidance(input, stateManager);

        } catch (error) {
            return `‚ùå Edit operation failed: ${error instanceof Error ? error.message : String(error)}`;
        }
    }

    /**
     * Handle editing a specific file
     */
    private async handleFileEdit(filename: string, input: string, stateManager: StateManager): Promise<string> {
        const fileData = Array.from(stateManager.codebaseIndex.values())
            .find(f => f.path.endsWith(filename));

        if (!fileData) {
            return `‚ùå File "${filename}" not found in indexed codebase.\n\n**Available files:** ${this.getAvailableFiles(stateManager).slice(0, 5).join(', ')}...`;
        }

        const editType = this.determineEditType(input);
        const relevantRules = this.getRelevantManifestoRules(input);

        let response = `üìù **Ready to edit ${filename}**\n\n`;
        response += `**Edit Type:** ${editType}\n`;
        response += `**Manifesto Rules:** ${relevantRules}\n\n`;

        // Show file context
        const preview = fileData.content.slice(0, 300) + (fileData.content.length > 300 ? '...' : '');
        response += `**Current Content Preview:**\n\`\`\`\n${preview}\n\`\`\`\n\n`;

        // Show symbols if available
        if (fileData.symbols && fileData.symbols.length > 0) {
            response += `**Available Symbols:** ${fileData.symbols.map((s: any) => `${s.name}(${s.type})`).join(', ')}\n\n`;
        }

        // Provide edit suggestions based on the request
        response += this.generateEditSuggestions(input, fileData, editType);

        return response;
    }

    /**
     * Provide general edit guidance
     */
    private provideEditGuidance(input: string, stateManager: StateManager): Promise<string> {
        const relevantRules = this.getRelevantManifestoRules(input);
        const editType = this.determineEditType(input);

        let response = `üìù **Smart Editing Ready**\n\n`;
        response += `**Request:** ${input}\n`;
        response += `**Edit Type:** ${editType}\n`;
        response += `**Manifesto Rules:** ${relevantRules}\n\n`;

        response += `**Smart editing features:**\n`;
        response += `‚Ä¢ üìñ Read existing files and understand context\n`;
        response += `‚Ä¢ üîó Analyze imports/exports and dependencies\n`;
        response += `‚Ä¢ üõ°Ô∏è Apply manifesto compliance automatically\n`;
        response += `‚Ä¢ üéØ Maintain existing code patterns and style\n`;
        response += `‚Ä¢ ‚úÖ Add proper error handling and validation\n\n`;

        response += `**To edit a specific file:** Mention the filename in your request\n`;
        response += `Example: "Edit UserService.ts to add validation"\n\n`;

        response += `**Available files:** ${this.getAvailableFiles(stateManager).slice(0, 8).join(', ')}`;

        return Promise.resolve(response);
    }

    /**
     * Determine the type of edit being requested
     */
    private determineEditType(input: string): string {
        const lowerInput = input.toLowerCase();

        if (lowerInput.includes('add') || lowerInput.includes('create')) {
            return 'Add new functionality';
        }
        if (lowerInput.includes('fix') || lowerInput.includes('repair')) {
            return 'Fix existing code';
        }
        if (lowerInput.includes('refactor') || lowerInput.includes('restructure')) {
            return 'Refactor/restructure';
        }
        if (lowerInput.includes('update') || lowerInput.includes('modify')) {
            return 'Update existing functionality';
        }
        if (lowerInput.includes('remove') || lowerInput.includes('delete')) {
            return 'Remove functionality';
        }
        if (lowerInput.includes('optimize') || lowerInput.includes('improve')) {
            return 'Optimize/improve';
        }

        return 'General modification';
    }

    /**
     * Generate specific edit suggestions based on the request
     */
    private generateEditSuggestions(input: string, fileData: any, editType: string): string {
        let suggestions = `**Edit Suggestions:**\n\n`;

        const lowerInput = input.toLowerCase();

        if (lowerInput.includes('error') || lowerInput.includes('handling')) {
            suggestions += `üõ°Ô∏è **Error Handling:**\n`;
            suggestions += `‚Ä¢ Add try-catch blocks around async operations\n`;
            suggestions += `‚Ä¢ Implement proper error logging and user feedback\n`;
            suggestions += `‚Ä¢ Add input validation with meaningful error messages\n\n`;
        }

        if (lowerInput.includes('test') || lowerInput.includes('testing')) {
            suggestions += `üß™ **Testing:**\n`;
            suggestions += `‚Ä¢ Add unit tests for new functionality\n`;
            suggestions += `‚Ä¢ Ensure 80%+ code coverage\n`;
            suggestions += `‚Ä¢ Add integration tests for API endpoints\n\n`;
        }

        if (lowerInput.includes('security') || lowerInput.includes('validation')) {
            suggestions += `üîí **Security:**\n`;
            suggestions += `‚Ä¢ Add input sanitization and validation\n`;
            suggestions += `‚Ä¢ Implement proper authentication checks\n`;
            suggestions += `‚Ä¢ Prevent XSS and injection vulnerabilities\n\n`;
        }

        if (lowerInput.includes('performance') || lowerInput.includes('optimize')) {
            suggestions += `‚ö° **Performance:**\n`;
            suggestions += `‚Ä¢ Add caching where appropriate\n`;
            suggestions += `‚Ä¢ Optimize database queries\n`;
            suggestions += `‚Ä¢ Ensure response times < 200ms\n\n`;
        }

        if (lowerInput.includes('documentation') || lowerInput.includes('docs')) {
            suggestions += `üìö **Documentation:**\n`;
            suggestions += `‚Ä¢ Add JSDoc comments for all public functions\n`;
            suggestions += `‚Ä¢ Document API endpoints and parameters\n`;
            suggestions += `‚Ä¢ Update README with new functionality\n\n`;
        }

        // Add general manifesto compliance suggestions
        suggestions += `üõ°Ô∏è **Manifesto Compliance:**\n`;
        suggestions += `‚Ä¢ Follow SOLID principles\n`;
        suggestions += `‚Ä¢ Use dependency injection patterns\n`;
        suggestions += `‚Ä¢ Maintain clear separation of concerns\n`;
        suggestions += `‚Ä¢ Add comprehensive logging\n\n`;

        suggestions += `üí° **Next Steps:** Specify exactly what you'd like to change, and I'll provide detailed implementation guidance.`;

        return suggestions;
    }

    /**
     * Get relevant manifesto rules based on the input
     */
    private getRelevantManifestoRules(input: string): string {
        const rules: string[] = [];
        const lowerInput = input.toLowerCase();

        if (lowerInput.includes('error') || lowerInput.includes('exception')) {
            rules.push('comprehensive error handling');
        }
        if (lowerInput.includes('test') || lowerInput.includes('testing')) {
            rules.push('unit tests required');
        }
        if (lowerInput.includes('security') || lowerInput.includes('auth')) {
            rules.push('input validation & security');
        }
        if (lowerInput.includes('performance') || lowerInput.includes('speed')) {
            rules.push('<200ms response times');
        }
        if (lowerInput.includes('documentation') || lowerInput.includes('docs')) {
            rules.push('JSDoc documentation');
        }

        if (rules.length === 0) {
            return 'error handling, input validation, testing, documentation';
        }

        return rules.join(', ');
    }

    /**
     * Get list of available files for editing
     */
    private getAvailableFiles(stateManager: StateManager): string[] {
        return Array.from(stateManager.codebaseIndex.keys())
            .map(path => path.split('/').pop() || path)
            .filter(filename => filename.match(/\.(ts|js|tsx|jsx|py|java|cs|cpp|h)$/i))
            .sort();
    }
}

==================== FILE: src/commands/GeneralHelpCommand.ts ====================
import { IChatCommand } from './IChatCommand';
import { StateManager } from '../core/StateManager';

/**
 * Command for handling general help and fallback requests
 * This command always handles input as the final fallback in the command chain
 */
export class GeneralHelpCommand implements IChatCommand {
    public readonly command = '/help';

    /**
     * This command always returns true as it serves as the final fallback
     */
    canHandle(input: string): boolean {
        return true; // Always handle as fallback
    }

    /**
     * Executes the general help command with intelligent routing
     */
    async execute(input: string, stateManager: StateManager): Promise<string> {
        try {
            // Check for test requests
            if (/\b(test|work|functionality|check)\b/i.test(input)) {
                return this.handleTestRequest(stateManager);
            }

            // Check for file reading requests
            if (/\b(read|show|open|view)\b/i.test(input) && /\.(ts|js|tsx|jsx|py|java|cs|cpp|h|md|json)\b/i.test(input)) {
                return this.handleFileRequest(input, stateManager);
            }

            // Check for MR/PR analysis requests
            if (/\b(mr|merge request|pull request|pr|analyze)\b/i.test(input) && /(github\.com|gitlab\.com|gitlab\.)/i.test(input)) {
                return this.handleMRRequest(input, stateManager);
            }

            // Default general response
            return this.provideGeneralHelp(input, stateManager);

        } catch (error) {
            return `‚ùå General help failed: ${error instanceof Error ? error.message : String(error)}`;
        }
    }

    /**
     * Handle test functionality requests
     */
    private handleTestRequest(stateManager: StateManager): string {
        return '‚úÖ Yes, Piggie works! Ready for manifesto-compliant development with full codebase awareness.';
    }

    /**
     * Handle file reading requests
     */
    private handleFileRequest(input: string, stateManager: StateManager): string {
        if (!stateManager.isCodebaseIndexed) {
            return '‚ö†Ô∏è Codebase not indexed. Click "üìö Index Codebase" first to read files.';
        }

        // Extract filename from request
        const fileMatch = input.match(/(\w+\.(ts|js|tsx|jsx|py|java|cs|cpp|h|md|json))/i);
        if (fileMatch) {
            const filename = fileMatch[1];
            const fileData = Array.from(stateManager.codebaseIndex.values()).find(f => f.path.endsWith(filename));

            if (fileData) {
                const preview = fileData.content.slice(0, 500) + (fileData.content.length > 500 ? '...' : '');
                let response = `üìÑ **${filename}** (${fileData.size} bytes)\n\n\`\`\`\n${preview}\n\`\`\`\n\n`;
                
                if (fileData.symbols && fileData.symbols.length > 0) {
                    response += `**Symbols found:** ${fileData.symbols.map((s: any) => `${s.name} (${s.type})`).join(', ')}\n`;
                }
                
                if (fileData.imports && fileData.imports.length > 0) {
                    response += `**Imports:** ${fileData.imports.join(', ')}`;
                }
                
                return response;
            } else {
                const availableFiles = Array.from(stateManager.codebaseIndex.keys())
                    .map(p => p.split('/').pop())
                    .slice(0, 5)
                    .join(', ');
                return `‚ùå File "${filename}" not found in indexed codebase. Available files: ${availableFiles}...`;
            }
        } else {
            return 'Please specify a filename to read (e.g., "show me extension.ts")';
        }
    }

    /**
     * Handle MR/PR analysis requests
     */
    private handleMRRequest(input: string, stateManager: StateManager): string {
        // Extract MR/PR URL from input
        const urlMatch = input.match(/(https?:\/\/(?:github\.com|gitlab\.com|gitlab\.[^\/]+)\/[^\s]+)/i);
        if (urlMatch) {
            const mrUrl = urlMatch[1];
            
            return `üîç **MR/PR Analysis Ready**

**URL:** ${mrUrl}

**Enterprise Analysis Includes:**
‚Ä¢ üìä Risk assessment (LOW/MEDIUM/HIGH)
‚Ä¢ üß™ Automated test suggestions
‚Ä¢ üõ°Ô∏è Manifesto compliance check
‚Ä¢ üîí Security vulnerability scan
‚Ä¢ ü§ñ Automation opportunities
‚Ä¢ üìà Impact and complexity analysis

**Manual Mode:** Enable Auto mode for immediate analysis, or I can guide you through manual review.`;
        } else {
            return 'Please provide a GitHub or GitLab MR/PR URL for analysis (e.g., "analyze https://github.com/owner/repo/pull/123")';
        }
    }

    /**
     * Provide general help and guidance
     */
    private provideGeneralHelp(input: string, stateManager: StateManager): string {
        let response = `üê∑ Piggie here! I understand you said: "${input}"\n\n`;
        
        if (stateManager.isCodebaseIndexed) {
            response += `üìö I have indexed ${stateManager.codebaseIndex.size} files in your codebase and can provide intelligent assistance.\n\n`;
        } else {
            response += `üí° Tip: Use the "Index Codebase" button to enable intelligent code analysis!\n\n`;
        }

        if (stateManager.isManifestoMode) {
            response += `üõ°Ô∏è Manifesto Mode is active - I'll ensure all suggestions follow best practices for error handling, input validation, and documentation.\n\n`;
        }

        // Show available commands
        response += `**Available Commands:**\n`;
        response += `‚Ä¢ **Code Generation:** "Create a UserService class", "Generate hello world"\n`;
        response += `‚Ä¢ **Editing:** "Edit UserService.ts", "Modify the login function"\n`;
        response += `‚Ä¢ **Linting:** "/lint", "Check code quality", "Fix errors in MyFile.ts"\n`;
        response += `‚Ä¢ **Code Analysis:** "/graph", "Show references for MyClass", "Analyze impact"\n`;
        response += `‚Ä¢ **Glossary:** "Define API as Application Programming Interface", "What does JWT mean?"\n`;
        response += `‚Ä¢ **Manifesto:** "/manifesto", "Show rules", "Generate QA manifesto"\n\n`;

        response += `**How can I help with your development needs?**`;

        return response;
    }
}

==================== FILE: src/commands/GlossaryCommand.ts ====================
import { IChatCommand } from './IChatCommand';
import { StateManager } from '../core/StateManager';

/**
 * Command for handling glossary-related requests
 * Handles patterns like "/glossary", "/define", "/lookup", and natural language glossary requests
 */
export class GlossaryCommand implements IChatCommand {
    public readonly command = '/glossary';

    /**
     * Determines if this command can handle the given input
     */
    canHandle(input: string): boolean {
        const trimmedInput = input.trim();
        
        // Handle slash commands
        if (/^\/(?:glossary|define|lookup)\b/i.test(trimmedInput)) {
            return true;
        }

        // Handle natural language glossary requests
        if (/\b(glossary|define|add term|add definition|what does.*mean|acronym)\b/i.test(input)) {
            return true;
        }

        // Handle definition patterns
        if (/define\s+\w+\s+as\s+/i.test(input) || /add term\s+\w+\s+meaning\s+/i.test(input)) {
            return true;
        }

        return false;
    }

    /**
     * Executes the glossary command
     */
    async execute(input: string, stateManager: StateManager): Promise<string> {
        try {
            const trimmedInput = input.trim();
            let response: string;

            // Handle specific slash commands
            if (/^\/define\b/i.test(trimmedInput)) {
                response = await this.handleDefineCommand(input, stateManager);
            }
            else if (/^\/lookup\b/i.test(trimmedInput)) {
                response = await this.handleLookupCommand(input, stateManager);
            }
            // Handle natural language patterns
            else if (/define\s+(\w+)\s+as\s+(.+)/i.test(input)) {
                response = await this.handleDefineTerm(input, stateManager);
            }
            else if (/add term\s+(\w+)\s+meaning\s+(.+)/i.test(input)) {
                response = await this.handleAddTerm(input, stateManager);
            }
            else if (/what does\s+(\w+)\s+mean/i.test(input)) {
                response = await this.handleLookupTerm(input, stateManager);
            }
            else if (/show glossary/i.test(input) || /^\/glossary$/i.test(trimmedInput)) {
                response = await this.showGlossary(stateManager);
            }
            else if (/remove\s+(\w+)/i.test(input)) {
                response = await this.removeTerm(input, stateManager);
            }
            else {
                // General glossary help
                response = this.provideGlossaryHelp(stateManager);
            }

            // Enhance response with glossary context before returning
            return this.enhanceResponseWithGlossary(response, stateManager);

        } catch (error) {
            return `‚ùå Glossary operation failed: ${error instanceof Error ? error.message : String(error)}`;
        }
    }

    /**
     * Handle /define command
     */
    private async handleDefineCommand(input: string, stateManager: StateManager): Promise<string> {
        const match = input.match(/\/define\s+(\w+)(?:\s+(.+))?/i);
        if (!match) {
            return `üìñ **Define Command Usage:**\n\n\`/define TERM definition here\`\n\nExample: \`/define API Application Programming Interface\``;
        }

        const [, term, definition] = match;
        
        if (!definition) {
            // Look up existing definition
            return await this.lookupSingleTerm(term, stateManager);
        }

        // Add new definition
        return await this.addTermToGlossary(term, definition, stateManager);
    }

    /**
     * Handle /lookup command
     */
    private async handleLookupCommand(input: string, stateManager: StateManager): Promise<string> {
        const match = input.match(/\/lookup\s+(\w+)/i);
        if (!match) {
            return `üîç **Lookup Command Usage:**\n\n\`/lookup TERM\`\n\nExample: \`/lookup API\``;
        }

        return await this.lookupSingleTerm(match[1], stateManager);
    }

    /**
     * Handle "define X as Y" pattern
     */
    private async handleDefineTerm(input: string, stateManager: StateManager): Promise<string> {
        const match = input.match(/define\s+(\w+)\s+as\s+(.+)/i);
        if (!match) {
            return `‚ùå Could not parse definition. Use format: "Define TERM as DEFINITION"`;
        }

        const [, term, definition] = match;
        return await this.addTermToGlossary(term, definition, stateManager);
    }

    /**
     * Handle "add term X meaning Y" pattern
     */
    private async handleAddTerm(input: string, stateManager: StateManager): Promise<string> {
        const match = input.match(/add term\s+(\w+)\s+meaning\s+(.+)/i);
        if (!match) {
            return `‚ùå Could not parse term addition. Use format: "Add term TERM meaning DEFINITION"`;
        }

        const [, term, definition] = match;
        return await this.addTermToGlossary(term, definition, stateManager);
    }

    /**
     * Handle "what does X mean" pattern
     */
    private async handleLookupTerm(input: string, stateManager: StateManager): Promise<string> {
        const match = input.match(/what does\s+(\w+)\s+mean/i);
        if (!match) {
            return `‚ùå Could not parse lookup request. Use format: "What does TERM mean?"`;
        }

        return await this.lookupSingleTerm(match[1], stateManager);
    }

    /**
     * Add a term to the glossary
     */
    private async addTermToGlossary(term: string, definition: string, stateManager: StateManager): Promise<string> {
        const normalizedTerm = term.toUpperCase();
        
        // Check if term already exists
        const existingTerm = stateManager.projectGlossary.get(normalizedTerm);
        if (existingTerm) {
            return `üìñ **Term "${term}" already exists**\n\n**Current definition:** ${existingTerm.definition}\n\n**New definition:** ${definition}\n\nUse "update term ${term} meaning ${definition}" to update it.`;
        }

        // Add new term
        stateManager.projectGlossary.set(normalizedTerm, {
            term: term,
            definition: definition,
            dateAdded: new Date().toISOString(),
            usage: 0
        });

        // Save glossary to storage
        await stateManager.saveGlossaryToStorage();

        return `‚úÖ **Added to glossary:**\n\n**${term}**: ${definition}\n\nüìä **Glossary now contains ${stateManager.projectGlossary.size} terms**`;
    }

    /**
     * Look up a single term
     */
    private async lookupSingleTerm(term: string, stateManager: StateManager): Promise<string> {
        const normalizedTerm = term.toUpperCase();
        const termData = stateManager.projectGlossary.get(normalizedTerm);

        if (!termData) {
            // Suggest similar terms
            const suggestions = this.findSimilarTerms(term, stateManager);
            let response = `‚ùå **Term "${term}" not found in glossary**\n\n`;
            
            if (suggestions.length > 0) {
                response += `**Did you mean:**\n`;
                suggestions.forEach(suggestion => {
                    response += `‚Ä¢ ${suggestion}\n`;
                });
                response += '\n';
            }
            
            response += `**To add it:** "Define ${term} as [definition]"`;
            return response;
        }

        // Increment usage counter
        termData.usage++;

        return `üìñ **${termData.term}**\n\n${termData.definition}\n\n*Added: ${new Date(termData.dateAdded).toLocaleDateString()}*\n*Used: ${termData.usage} times*`;
    }

    /**
     * Show the entire glossary
     */
    private async showGlossary(stateManager: StateManager): Promise<string> {
        if (stateManager.projectGlossary.size === 0) {
            return `üìñ **Glossary is empty**\n\n**Get started:**\n‚Ä¢ "Define API as Application Programming Interface"\n‚Ä¢ "Add term SLA meaning Service Level Agreement"\n‚Ä¢ "/define JWT JSON Web Token"`;
        }

        let response = `üìñ **Project Glossary** (${stateManager.projectGlossary.size} terms)\n\n`;

        // Sort terms by usage (most used first)
        const sortedTerms = Array.from(stateManager.projectGlossary.entries())
            .sort(([,a], [,b]) => b.usage - a.usage);

        // Show up to 10 terms to avoid overwhelming the chat
        const termsToShow = sortedTerms.slice(0, 10);
        
        termsToShow.forEach(([key, termData]) => {
            response += `**${termData.term}**: ${termData.definition}\n`;
            if (termData.usage > 0) {
                response += `*Used ${termData.usage} times*\n`;
            }
            response += '\n';
        });

        if (sortedTerms.length > 10) {
            response += `... and ${sortedTerms.length - 10} more terms\n\n`;
        }

        response += `**Commands:**\n`;
        response += `‚Ä¢ "What does [term] mean?" - Look up definition\n`;
        response += `‚Ä¢ "Define [term] as [definition]" - Add new term\n`;
        response += `‚Ä¢ "Remove [term]" - Delete term\n`;

        return response;
    }

    /**
     * Remove a term from the glossary
     */
    private async removeTerm(input: string, stateManager: StateManager): Promise<string> {
        const match = input.match(/remove\s+(\w+)/i);
        if (!match) {
            return `‚ùå Could not parse remove request. Use format: "Remove TERM"`;
        }

        const term = match[1];
        const normalizedTerm = term.toUpperCase();
        
        if (!stateManager.projectGlossary.has(normalizedTerm)) {
            return `‚ùå **Term "${term}" not found in glossary**\n\nUse "show glossary" to see available terms.`;
        }

        const termData = stateManager.projectGlossary.get(normalizedTerm);
        stateManager.projectGlossary.delete(normalizedTerm);

        // Save glossary to storage
        await stateManager.saveGlossaryToStorage();

        return `‚úÖ **Removed from glossary:**\n\n**${termData?.term}**: ${termData?.definition}\n\nüìä **Glossary now contains ${stateManager.projectGlossary.size} terms**`;
    }

    /**
     * Find similar terms for suggestions
     */
    private findSimilarTerms(searchTerm: string, stateManager: StateManager): string[] {
        const suggestions: string[] = [];
        const lowerSearchTerm = searchTerm.toLowerCase();

        for (const [, termData] of stateManager.projectGlossary) {
            const lowerTerm = termData.term.toLowerCase();
            
            // Check for partial matches
            if (lowerTerm.includes(lowerSearchTerm) || lowerSearchTerm.includes(lowerTerm)) {
                suggestions.push(termData.term);
            }
            // Check for similar starting letters
            else if (lowerTerm.startsWith(lowerSearchTerm.charAt(0)) && suggestions.length < 3) {
                suggestions.push(termData.term);
            }
        }

        return suggestions.slice(0, 5); // Limit to 5 suggestions
    }

    /**
     * Enhance response with glossary context
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public enhanceResponseWithGlossary(content: string, stateManager: StateManager): string {
        try {
            if (stateManager.projectGlossary.size === 0) {
                return content;
            }

            let enhancedContent = content;

            // Add glossary definitions for terms found in the response
            for (const [key, termData] of stateManager.projectGlossary) {
                const term = termData.term;
                if (enhancedContent.toLowerCase().includes(term.toLowerCase())) {
                    // Mark usage
                    termData.usage++;
                }
            }

            return enhancedContent;
        } catch (error) {
            console.error('Failed to enhance response with glossary:', error);
            return content;
        }
    }

    /**
     * Provide general glossary help
     */
    private provideGlossaryHelp(stateManager: StateManager): string {
        let response = `üìñ **Glossary Commands:**\n\n`;

        response += `**Add terms:**\n`;
        response += `‚Ä¢ "Define API as Application Programming Interface"\n`;
        response += `‚Ä¢ "Add term SLA meaning Service Level Agreement"\n`;
        response += `‚Ä¢ "/define JWT JSON Web Token"\n\n`;

        response += `**Look up terms:**\n`;
        response += `‚Ä¢ "What does API mean?"\n`;
        response += `‚Ä¢ "/lookup SLA"\n\n`;

        response += `**Manage glossary:**\n`;
        response += `‚Ä¢ "Show glossary" - List all terms\n`;
        response += `‚Ä¢ "Remove API" - Delete a term\n\n`;

        response += `**Current glossary:** ${stateManager.projectGlossary.size} terms defined`;

        if (stateManager.projectGlossary.size > 0) {
            const recentTerms = Array.from(stateManager.projectGlossary.values())
                .sort((a, b) => new Date(b.dateAdded).getTime() - new Date(a.dateAdded).getTime())
                .slice(0, 3)
                .map(term => term.term);

            response += `\n\n**Recent terms:** ${recentTerms.join(', ')}`;
        }

        return response;
    }
}

==================== FILE: src/commands/GraphCommand.ts ====================
import { IChatCommand } from './IChatCommand';
import { StateManager } from '../core/StateManager';

/**
 * Command for handling code graph and analysis requests
 * Handles patterns like "/references", "/impact", "/graph"
 */
export class GraphCommand implements IChatCommand {
    public readonly command = '/graph';

    /**
     * Determines if this command can handle the given input
     */
    canHandle(input: string): boolean {
        const trimmedInput = input.trim();
        
        // Handle slash commands for code graph analysis
        if (/^\/(?:references|impact|graph)\b/i.test(trimmedInput)) {
            return true;
        }

        // Handle natural language graph requests
        if (/\b(references|dependencies|impact|graph|analyze|structure|relationships)\b/i.test(input) &&
            /\b(code|codebase|project|files|modules)\b/i.test(input)) {
            return true;
        }

        return false;
    }

    /**
     * Executes the graph command
     */
    async execute(input: string, stateManager: StateManager): Promise<string> {
        try {
            if (!stateManager.isCodebaseIndexed) {
                return `‚ö†Ô∏è **Codebase not indexed yet!**\n\nI need to analyze your codebase first to generate code graphs.\n\nPlease click "üìö Index Codebase" first, then try again.`;
            }

            const trimmedInput = input.trim();

            // Determine the type of graph analysis requested
            if (/^\/references\b/i.test(trimmedInput) || /\breferences\b/i.test(input)) {
                return await this.analyzeReferences(input, stateManager);
            }
            
            if (/^\/impact\b/i.test(trimmedInput) || /\bimpact\b/i.test(input)) {
                return await this.analyzeImpact(input, stateManager);
            }

            // General graph analysis
            return await this.generateCodeGraph(stateManager);

        } catch (error) {
            return `‚ùå Graph analysis failed: ${error instanceof Error ? error.message : String(error)}`;
        }
    }

    /**
     * Analyze references for a specific symbol or file
     */
    private async analyzeReferences(input: string, stateManager: StateManager): Promise<string> {
        // Extract symbol or file name from input
        const symbolMatch = input.match(/(?:references?\s+(?:for\s+)?|\/references\s+)(\w+)/i);
        const fileMatch = input.match(/(\w+\.(ts|js|tsx|jsx|py|java|cs|cpp|h))/i);

        if (symbolMatch) {
            return this.findSymbolReferences(symbolMatch[1], stateManager);
        }

        if (fileMatch) {
            return this.findFileReferences(fileMatch[1], stateManager);
        }

        return `üîç **Reference Analysis**\n\nPlease specify what to analyze:\n\n**Examples:**\n‚Ä¢ "/references UserService" - Find all references to UserService\n‚Ä¢ "/references UserService.ts" - Find all files that import UserService.ts\n‚Ä¢ "Show references for validateInput" - Find where validateInput is used`;
    }

    /**
     * Analyze impact of changes to a specific symbol or file
     */
    private async analyzeImpact(input: string, stateManager: StateManager): Promise<string> {
        const symbolMatch = input.match(/(?:impact\s+(?:of\s+)?|\/impact\s+)(\w+)/i);
        const fileMatch = input.match(/(\w+\.(ts|js|tsx|jsx|py|java|cs|cpp|h))/i);

        if (symbolMatch) {
            return this.analyzeSymbolImpact(symbolMatch[1], stateManager);
        }

        if (fileMatch) {
            return this.analyzeFileImpact(fileMatch[1], stateManager);
        }

        return `üìä **Impact Analysis**\n\nPlease specify what to analyze:\n\n**Examples:**\n‚Ä¢ "/impact UserService" - Analyze impact of changing UserService\n‚Ä¢ "/impact database.ts" - Analyze impact of changing database.ts\n‚Ä¢ "What's the impact of modifying validateUser?" - Analyze function impact`;
    }

    /**
     * Generate a general code graph overview
     */
    private async generateCodeGraph(stateManager: StateManager): Promise<string> {
        const stats = this.calculateCodebaseStats(stateManager);
        const dependencies = this.analyzeDependencies(stateManager);
        const hotspots = this.identifyHotspots(stateManager);

        let response = `üìä **Codebase Graph Analysis**\n\n`;
        
        response += `**Overview:**\n`;
        response += `‚Ä¢ ${stats.totalFiles} files indexed\n`;
        response += `‚Ä¢ ${stats.totalFunctions} functions found\n`;
        response += `‚Ä¢ ${stats.totalClasses} classes found\n`;
        response += `‚Ä¢ ${stats.totalInterfaces} interfaces found\n\n`;

        response += `**Dependencies:**\n`;
        dependencies.slice(0, 5).forEach(dep => {
            response += `‚Ä¢ ${dep.file} ‚Üí imports ${dep.imports.length} modules\n`;
        });
        response += '\n';

        response += `**Complexity Hotspots:**\n`;
        hotspots.slice(0, 5).forEach(hotspot => {
            response += `‚Ä¢ ${hotspot.file} (${hotspot.complexity} complexity score)\n`;
        });
        response += '\n';

        response += `**Available Commands:**\n`;
        response += `‚Ä¢ "/references [symbol]" - Find where a symbol is used\n`;
        response += `‚Ä¢ "/impact [file]" - Analyze change impact\n`;
        response += `‚Ä¢ "/graph dependencies" - Show dependency graph\n`;

        return response;
    }

    /**
     * Find all references to a specific symbol
     */
    private findSymbolReferences(symbolName: string, stateManager: StateManager): string {
        const references: Array<{file: string, line: number, context: string}> = [];

        for (const [filePath, fileData] of stateManager.codebaseIndex) {
            const lines = fileData.content.split('\n');
            lines.forEach((line: string, index: number) => {
                if (line.includes(symbolName) && !line.trim().startsWith('//')) {
                    references.push({
                        file: filePath.split('/').pop() || filePath,
                        line: index + 1,
                        context: line.trim()
                    });
                }
            });
        }

        if (references.length === 0) {
            return `üîç **No references found for "${symbolName}"**\n\nThe symbol might be:\n‚Ä¢ Misspelled\n‚Ä¢ Not in indexed files\n‚Ä¢ Used in comments only`;
        }

        let response = `üîç **References for "${symbolName}"** (${references.length} found)\n\n`;
        
        references.slice(0, 10).forEach(ref => {
            response += `**${ref.file}:${ref.line}**\n`;
            response += `\`${ref.context}\`\n\n`;
        });

        if (references.length > 10) {
            response += `... and ${references.length - 10} more references\n\n`;
        }

        response += `üí° **Impact**: Changes to "${symbolName}" will affect ${references.length} locations`;

        return response;
    }

    /**
     * Find all files that reference a specific file
     */
    private findFileReferences(filename: string, stateManager: StateManager): string {
        const references: Array<{file: string, importLine: string}> = [];
        const baseFilename = filename.replace(/\.(ts|js|tsx|jsx)$/, '');

        for (const [filePath, fileData] of stateManager.codebaseIndex) {
            const lines = fileData.content.split('\n');
            lines.forEach((line: string) => {
                if (line.includes('import') &&
                    (line.includes(filename) || line.includes(baseFilename))) {
                    references.push({
                        file: filePath.split('/').pop() || filePath,
                        importLine: line.trim()
                    });
                }
            });
        }

        if (references.length === 0) {
            return `üîç **No imports found for "${filename}"**\n\nThe file might be:\n‚Ä¢ Not imported by other files\n‚Ä¢ Used differently (require, dynamic imports)\n‚Ä¢ Not in the indexed codebase`;
        }

        let response = `üîç **Files importing "${filename}"** (${references.length} found)\n\n`;
        
        references.forEach(ref => {
            response += `**${ref.file}**\n`;
            response += `\`${ref.importLine}\`\n\n`;
        });

        response += `üí° **Impact**: Changes to "${filename}" will affect ${references.length} importing files`;

        return response;
    }

    /**
     * Analyze the impact of changing a specific symbol
     */
    private analyzeSymbolImpact(symbolName: string, stateManager: StateManager): string {
        const references = this.findSymbolReferences(symbolName, stateManager);
        const referenceCount = (references.match(/\*\*/g) || []).length / 2; // Rough count

        let impact = 'LOW';
        if (referenceCount > 10) impact = 'HIGH';
        else if (referenceCount > 5) impact = 'MEDIUM';

        let response = `üìä **Impact Analysis for "${symbolName}"**\n\n`;
        response += `**Risk Level:** ${impact}\n`;
        response += `**Affected Locations:** ${referenceCount}\n\n`;

        response += `**Recommendations:**\n`;
        if (impact === 'HIGH') {
            response += `‚Ä¢ ‚ö†Ô∏è High-risk change - extensive testing required\n`;
            response += `‚Ä¢ Consider backward compatibility\n`;
            response += `‚Ä¢ Plan phased rollout\n`;
            response += `‚Ä¢ Update all affected documentation\n`;
        } else if (impact === 'MEDIUM') {
            response += `‚Ä¢ üî∂ Medium-risk change - thorough testing needed\n`;
            response += `‚Ä¢ Review all affected files\n`;
            response += `‚Ä¢ Update relevant tests\n`;
        } else {
            response += `‚Ä¢ ‚úÖ Low-risk change - standard testing sufficient\n`;
            response += `‚Ä¢ Verify functionality in affected areas\n`;
        }

        response += `\n${references}`;

        return response;
    }

    /**
     * Analyze the impact of changing a specific file
     */
    private analyzeFileImpact(filename: string, stateManager: StateManager): string {
        const references = this.findFileReferences(filename, stateManager);
        const referenceCount = (references.match(/\*\*/g) || []).length / 2;

        let impact = 'LOW';
        if (referenceCount > 8) impact = 'HIGH';
        else if (referenceCount > 3) impact = 'MEDIUM';

        let response = `üìä **Impact Analysis for "${filename}"**\n\n`;
        response += `**Risk Level:** ${impact}\n`;
        response += `**Importing Files:** ${referenceCount}\n\n`;

        response += `**Change Impact:**\n`;
        if (impact === 'HIGH') {
            response += `‚Ä¢ ‚ö†Ô∏è Core module - changes affect many files\n`;
            response += `‚Ä¢ Breaking changes will cascade\n`;
            response += `‚Ä¢ Requires comprehensive regression testing\n`;
        } else if (impact === 'MEDIUM') {
            response += `‚Ä¢ üî∂ Shared module - moderate impact\n`;
            response += `‚Ä¢ Test all importing modules\n`;
            response += `‚Ä¢ Check for breaking changes\n`;
        } else {
            response += `‚Ä¢ ‚úÖ Isolated module - minimal impact\n`;
            response += `‚Ä¢ Standard testing procedures apply\n`;
        }

        response += `\n${references}`;

        return response;
    }

    /**
     * Calculate basic codebase statistics
     */
    private calculateCodebaseStats(stateManager: StateManager): any {
        let totalFunctions = 0;
        let totalClasses = 0;
        let totalInterfaces = 0;

        for (const [, fileData] of stateManager.codebaseIndex) {
            const content = fileData.content;
            totalFunctions += (content.match(/function\s+\w+/g) || []).length;
            totalClasses += (content.match(/class\s+\w+/g) || []).length;
            totalInterfaces += (content.match(/interface\s+\w+/g) || []).length;
        }

        return {
            totalFiles: stateManager.codebaseIndex.size,
            totalFunctions,
            totalClasses,
            totalInterfaces
        };
    }

    /**
     * Analyze dependencies between files
     */
    private analyzeDependencies(stateManager: StateManager): Array<{file: string, imports: string[]}> {
        const dependencies: Array<{file: string, imports: string[]}> = [];

        for (const [filePath, fileData] of stateManager.codebaseIndex) {
            const imports = fileData.content
                .split('\n')
                .filter((line: string) => line.trim().startsWith('import'))
                .map((line: string) => line.trim());

            if (imports.length > 0) {
                dependencies.push({
                    file: filePath.split('/').pop() || filePath,
                    imports
                });
            }
        }

        return dependencies.sort((a, b) => b.imports.length - a.imports.length);
    }

    /**
     * Identify complexity hotspots in the codebase
     */
    private identifyHotspots(stateManager: StateManager): Array<{file: string, complexity: number}> {
        const hotspots: Array<{file: string, complexity: number}> = [];

        for (const [filePath, fileData] of stateManager.codebaseIndex) {
            const content = fileData.content;
            
            // Simple complexity calculation based on various factors
            let complexity = 0;
            complexity += (content.match(/if\s*\(/g) || []).length * 1;
            complexity += (content.match(/for\s*\(/g) || []).length * 2;
            complexity += (content.match(/while\s*\(/g) || []).length * 2;
            complexity += (content.match(/switch\s*\(/g) || []).length * 3;
            complexity += (content.match(/catch\s*\(/g) || []).length * 1;
            complexity += Math.floor(content.length / 1000); // Size factor

            if (complexity > 5) {
                hotspots.push({
                    file: filePath.split('/').pop() || filePath,
                    complexity
                });
            }
        }

        return hotspots.sort((a, b) => b.complexity - a.complexity);
    }
}

==================== FILE: src/commands/IChatCommand.ts ====================
import { StateManager } from '../core/StateManager';

/**
 * Interface for all chat commands in the Command Pattern
 * Each command handles a specific type of user input and provides a consistent interface
 */
export interface IChatCommand {
    /**
     * The primary trigger for this command (e.g., "/lint", "/edit", "/graph")
     */
    command: string;

    /**
     * Determines if this command can handle the given user input
     * @param input - The user's input message
     * @returns true if this command can handle the input, false otherwise
     */
    canHandle(input: string): boolean;

    /**
     * Executes the command with the given input and state manager
     * @param input - The user's input message
     * @param stateManager - The state manager instance for accessing codebase data
     * @returns Promise resolving to the response message
     */
    execute(input: string, stateManager: StateManager): Promise<string>;
}

==================== FILE: src/commands/index.ts ====================
/**
 * Command Pattern exports for the Manifesto Enforcer chat system
 * This file provides a clean interface for importing all command-related classes
 */

export { IChatCommand } from './IChatCommand';
export { ChatCommandManager } from './ChatCommandManager';
export { LintCommand } from './LintCommand';
export { EditCommand } from './EditCommand';
export { GraphCommand } from './GraphCommand';
export { GlossaryCommand } from './GlossaryCommand';
export { ManifestoCommand } from './ManifestoCommand';
export { CodeCommand } from './CodeCommand';
export { GeneralHelpCommand } from './GeneralHelpCommand';

==================== FILE: src/commands/LintCommand.ts ====================
import { IChatCommand } from './IChatCommand';
import { StateManager } from '../core/StateManager';

/**
 * Command for handling lint and fix requests
 * Handles patterns like "/lint", "/fix", and general linting requests
 */
export class LintCommand implements IChatCommand {
    public readonly command = '/lint';

    /**
     * Determines if this command can handle the given input
     */
    canHandle(input: string): boolean {
        const trimmedInput = input.trim();
        
        // Handle slash commands
        if (/^\/(?:lint|fix)\b/i.test(trimmedInput)) {
            return true;
        }

        // Handle natural language lint requests
        if (/\b(lint|linting|fix|fixing|check|validate|analyze)\b/i.test(input) &&
            /\b(code|file|project|errors|warnings|issues)\b/i.test(input)) {
            return true;
        }

        return false;
    }

    /**
     * Executes the lint command
     */
    async execute(input: string, stateManager: StateManager): Promise<string> {
        try {
            if (!stateManager.isCodebaseIndexed) {
                return `‚ö†Ô∏è **Codebase not indexed yet!**\n\nI need to analyze your codebase first to provide linting.\n\nPlease click "üìö Index Codebase" first, then try again.`;
            }

            // Check if specific file is mentioned
            const fileMatch = input.match(/(\w+\.(ts|js|tsx|jsx|py|java|cs|cpp|h))/i);
            if (fileMatch) {
                return await this.lintSpecificFile(fileMatch[1], stateManager);
            }

            // General project linting
            return await this.lintProject(stateManager);

        } catch (error) {
            return `‚ùå Linting failed: ${error instanceof Error ? error.message : String(error)}`;
        }
    }

    /**
     * Lint a specific file
     */
    private async lintSpecificFile(filename: string, stateManager: StateManager): Promise<string> {
        const fileData = Array.from(stateManager.codebaseIndex.values())
            .find(f => f.path.endsWith(filename));

        if (!fileData) {
            return `‚ùå File "${filename}" not found in indexed codebase.`;
        }

        const issues = this.analyzeFileForIssues(fileData.content, filename);
        
        if (issues.length === 0) {
            return `‚úÖ **${filename}** looks good!\n\nNo manifesto compliance issues found.`;
        }

        let response = `üîç **Linting Results for ${filename}:**\n\n`;
        issues.forEach((issue, index) => {
            response += `${index + 1}. **${issue.severity}**: ${issue.message}\n`;
            if (issue.line) {
                response += `   Line ${issue.line}: \`${issue.code}\`\n`;
            }
            response += `   **Fix**: ${issue.fix}\n\n`;
        });

        return response;
    }

    /**
     * Lint the entire project
     */
    private async lintProject(stateManager: StateManager): Promise<string> {
        const allIssues: Array<{file: string, issues: any[]}> = [];
        let totalIssues = 0;

        // Analyze up to 10 files to avoid overwhelming response
        const filesToAnalyze = Array.from(stateManager.codebaseIndex.values()).slice(0, 10);

        for (const fileData of filesToAnalyze) {
            const issues = this.analyzeFileForIssues(fileData.content, fileData.path);
            if (issues.length > 0) {
                allIssues.push({
                    file: fileData.path.split('/').pop() || fileData.path,
                    issues
                });
                totalIssues += issues.length;
            }
        }

        if (totalIssues === 0) {
            return `‚úÖ **Project Linting Complete**\n\nNo manifesto compliance issues found in ${filesToAnalyze.length} analyzed files.\n\nüõ°Ô∏è Your codebase follows manifesto standards!`;
        }

        let response = `üîç **Project Linting Results**\n\n`;
        response += `**Summary**: ${totalIssues} issues found across ${allIssues.length} files\n\n`;

        allIssues.forEach(({file, issues}) => {
            response += `**${file}** (${issues.length} issues):\n`;
            issues.slice(0, 3).forEach(issue => {
                response += `‚Ä¢ ${issue.severity}: ${issue.message}\n`;
            });
            if (issues.length > 3) {
                response += `‚Ä¢ ... and ${issues.length - 3} more issues\n`;
            }
            response += '\n';
        });

        response += `üí° **Tip**: Use "/lint filename.ts" to get detailed fixes for a specific file.`;

        return response;
    }

    /**
     * Analyze file content for manifesto compliance issues
     */
    private analyzeFileForIssues(content: string, filename: string): Array<{
        severity: string;
        message: string;
        line?: number;
        code?: string;
        fix: string;
    }> {
        const issues: any[] = [];
        const lines = content.split('\n');

        // Check for missing error handling
        if (content.includes('function') && !content.includes('try') && !content.includes('catch')) {
            issues.push({
                severity: 'HIGH',
                message: 'Missing error handling',
                fix: 'Add try-catch blocks around function logic'
            });
        }

        // Check for missing input validation
        if (content.includes('function') && !content.includes('if') && !content.includes('throw')) {
            issues.push({
                severity: 'MEDIUM',
                message: 'Missing input validation',
                fix: 'Add parameter validation with appropriate error throwing'
            });
        }

        // Check for missing JSDoc documentation
        const functionMatches = content.match(/(?:export\s+)?(?:async\s+)?function\s+\w+/g);
        const jsdocMatches = content.match(/\/\*\*[\s\S]*?\*\//g);
        
        if (functionMatches && functionMatches.length > 0) {
            const functionCount = functionMatches.length;
            const jsdocCount = jsdocMatches ? jsdocMatches.length : 0;
            
            if (jsdocCount < functionCount) {
                issues.push({
                    severity: 'MEDIUM',
                    message: `${functionCount - jsdocCount} functions missing JSDoc documentation`,
                    fix: 'Add JSDoc comments above function declarations'
                });
            }
        }

        // Check for potential security issues
        if (content.includes('innerHTML')) {
            const lineNumber = lines.findIndex(line => line.includes('innerHTML')) + 1;
            issues.push({
                severity: 'HIGH',
                message: 'Potential XSS vulnerability with innerHTML',
                line: lineNumber,
                code: lines[lineNumber - 1]?.trim(),
                fix: 'Use textContent or proper DOM manipulation instead of innerHTML'
            });
        }

        // Check for console.log in production code (if not in test files)
        if (!filename.includes('test') && !filename.includes('spec') && content.includes('console.log')) {
            issues.push({
                severity: 'LOW',
                message: 'Console.log statements found',
                fix: 'Replace with proper logging framework or remove for production'
            });
        }

        return issues;
    }
}

==================== FILE: src/commands/ManifestoCommand.ts ====================
import { IChatCommand } from './IChatCommand';
import { StateManager } from '../core/StateManager';

/**
 * Command for handling manifesto-related requests
 * Handles patterns like "/manifesto", manifesto display, and manifesto generation
 */
export class ManifestoCommand implements IChatCommand {
    public readonly command = '/manifesto';

    /**
     * Determines if this command can handle the given input
     */
    canHandle(input: string): boolean {
        const trimmedInput = input.trim();
        
        // Handle slash commands
        if (/^\/manifesto\b/i.test(trimmedInput)) {
            return true;
        }

        // Handle manifesto display requests
        if (/\b(manifesto|rules|read|show|display)\b/i.test(input) && /\b(manifesto|rules)\b/i.test(input)) {
            return true;
        }

        // Handle manifesto generation requests
        if (/\b(generate|create)\b.*\b(manifesto|qa manifesto|testing manifesto|security manifesto|api manifesto|frontend manifesto)\b/i.test(input)) {
            return true;
        }

        return false;
    }

    /**
     * Executes the manifesto command
     */
    async execute(input: string, stateManager: StateManager): Promise<string> {
        try {
            // Check for manifesto generation requests
            if (/\b(generate|create)\b.*\b(manifesto)\b/i.test(input)) {
                return await this.handleManifestoGeneration(input, stateManager);
            }

            // Default to showing manifesto
            return await this.showManifesto(stateManager);

        } catch (error) {
            return `‚ùå Manifesto operation failed: ${error instanceof Error ? error.message : String(error)}`;
        }
    }

    /**
     * Show the current manifesto
     */
    private async showManifesto(stateManager: StateManager): Promise<string> {
        // Try to read manifesto.md from workspace
        const manifestoContent = await this.readManifestoFile();
        
        if (manifestoContent) {
            return this.formatManifestoDisplay(manifestoContent);
        }

        // Fallback to built-in manifesto rules
        return this.showBuiltInManifesto(stateManager);
    }

    /**
     * Read manifesto.md file from workspace
     */
    private async readManifestoFile(): Promise<string | null> {
        try {
            // This would need to be implemented with actual file system access
            // For now, return null to use built-in manifesto
            return null;
        } catch (error) {
            return null;
        }
    }

    /**
     * Format manifesto content for display
     */
    private formatManifestoDisplay(manifestoContent: string): string {
        // Truncate if too long for chat
        const maxLength = 2000;
        let response = `üìã **Project Manifesto**\n\n`;

        if (manifestoContent.length > maxLength) {
            response += manifestoContent.substring(0, maxLength) + '\n\n... (truncated)\n\n';
            response += `üí° **Full manifesto available in:**\n‚Ä¢ üìã Manifesto sidebar panel\n‚Ä¢ manifesto.md file in workspace`;
        } else {
            response += manifestoContent;
        }

        return response;
    }

    /**
     * Show built-in manifesto rules
     */
    private showBuiltInManifesto(stateManager: StateManager): string {
        let response = `üìã **Development Manifesto Summary:**\n\n`;

        response += `**Core Directives:**\n`;
        response += `‚Ä¢ All code must have comprehensive error handling\n`;
        response += `‚Ä¢ JSDoc documentation required for all public functions\n`;
        response += `‚Ä¢ Unit tests mandatory for all business logic\n`;
        response += `‚Ä¢ 80%+ code coverage required\n`;
        response += `‚Ä¢ SOLID principles enforced\n`;
        response += `‚Ä¢ Input validation on all user-facing functions\n`;
        response += `‚Ä¢ API responses must be under 200ms\n`;
        response += `‚Ä¢ Security analysis required for all changes\n\n`;

        response += `**Key Prohibitions:**\n`;
        response += `‚Ä¢ No iframes/webviews in VSCode extensions\n`;
        response += `‚Ä¢ No innerHTML usage (XSS prevention)\n`;
        response += `‚Ä¢ No SQL injection vulnerabilities\n\n`;

        response += `**Architecture Requirements:**\n`;
        response += `‚Ä¢ Interface-based programming for services\n`;
        response += `‚Ä¢ Repository pattern for data access\n`;
        response += `‚Ä¢ Dependency injection patterns\n`;
        response += `‚Ä¢ Clear separation of concerns\n\n`;

        if (stateManager.manifestoRules && stateManager.manifestoRules.length > 0) {
            response += `**Indexed Rules:** ${stateManager.manifestoRules.length} rules loaded\n\n`;
        }

        response += `The full manifesto is in manifesto.md in your workspace.`;

        return response;
    }

    /**
     * Handle manifesto generation requests
     */
    private async handleManifestoGeneration(input: string, stateManager: StateManager): Promise<string> {
        if (!stateManager.isCodebaseIndexed) {
            return `‚ö†Ô∏è **Codebase not indexed yet!**\n\nI need to analyze your codebase first to generate relevant manifestos.\n\nPlease click "üìö Index Codebase" first, then try again.`;
        }

        // Determine manifesto type
        const manifestoType = this.determineManifestoType(input);
        
        // Analyze codebase for manifesto opportunities
        const analysis = await this.analyzeManifestoOpportunities(stateManager);

        if (analysis.suggestions.length === 0) {
            return this.provideManifestoGenerationOptions();
        }

        return this.generateManifestoResponse(manifestoType, analysis);
    }

    /**
     * Determine the type of manifesto to generate
     */
    private determineManifestoType(input: string): string {
        const lowerInput = input.toLowerCase();

        if (lowerInput.includes('qa') || lowerInput.includes('testing')) {
            return 'QA/Testing';
        }
        if (lowerInput.includes('security')) {
            return 'Security';
        }
        if (lowerInput.includes('api')) {
            return 'API';
        }
        if (lowerInput.includes('frontend') || lowerInput.includes('ui')) {
            return 'Frontend/UI';
        }
        if (lowerInput.includes('performance')) {
            return 'Performance';
        }

        return 'General';
    }

    /**
     * Analyze codebase for manifesto opportunities
     */
    private async analyzeManifestoOpportunities(stateManager: StateManager): Promise<{ suggestions: string[] }> {
        try {
            const suggestions: string[] = [];
            
            // Analyze indexed files for manifesto compliance opportunities
            for (const [filePath, fileData] of stateManager.codebaseIndex) {
                const content = fileData.content;
                
                // Check for missing error handling
                if (content.includes('function') && !content.includes('try') && !content.includes('catch')) {
                    suggestions.push(`‚Ä¢ ${filePath.split('/').pop()}: Consider adding error handling`);
                }
                
                // Check for missing input validation
                if (content.includes('function') && !content.includes('if') && !content.includes('throw')) {
                    suggestions.push(`‚Ä¢ ${filePath.split('/').pop()}: Consider adding input validation`);
                }

                // Check for missing documentation
                const functionCount = (content.match(/function\s+\w+/g) || []).length;
                const jsdocCount = (content.match(/\/\*\*[\s\S]*?\*\//g) || []).length;
                if (functionCount > jsdocCount) {
                    suggestions.push(`‚Ä¢ ${filePath.split('/').pop()}: Missing JSDoc documentation`);
                }
            }

            return { suggestions: suggestions.slice(0, 5) }; // Limit to 5 suggestions
        } catch (error) {
            console.error('Failed to analyze manifesto opportunities:', error);
            return { suggestions: [] };
        }
    }

    /**
     * Provide manifesto generation options
     */
    private provideManifestoGenerationOptions(): string {
        let response = `üìã **Ready to generate manifestos!**\n\n`;
        response += `I can create manifestos based on your codebase patterns:\n\n`;

        response += `**Available types:**\n`;
        response += `‚Ä¢ "Generate QA manifesto" - Testing standards\n`;
        response += `‚Ä¢ "Generate security manifesto" - Security guidelines\n`;
        response += `‚Ä¢ "Generate API manifesto" - API standards\n`;
        response += `‚Ä¢ "Generate frontend manifesto" - UI component standards\n`;
        response += `‚Ä¢ "Generate performance manifesto" - Performance guidelines\n\n`;

        response += `What type would you like me to create?`;

        return response;
    }

    /**
     * Generate manifesto response based on analysis
     */
    private generateManifestoResponse(manifestoType: string, analysis: { suggestions: string[] }): string {
        let response = `üìã **${manifestoType} Manifesto Generation**\n\n`;

        response += `**Based on your codebase analysis:**\n\n`;
        response += analysis.suggestions.join('\n') + '\n\n';

        response += `**Recommended ${manifestoType} Standards:**\n\n`;

        switch (manifestoType) {
            case 'QA/Testing':
                response += this.generateQAManifesto();
                break;
            case 'Security':
                response += this.generateSecurityManifesto();
                break;
            case 'API':
                response += this.generateAPIManifesto();
                break;
            case 'Frontend/UI':
                response += this.generateFrontendManifesto();
                break;
            case 'Performance':
                response += this.generatePerformanceManifesto();
                break;
            default:
                response += this.generateGeneralManifesto();
        }

        response += `\n\n**To generate:** Just say "Generate ${manifestoType.toLowerCase()} manifesto"`;

        return response;
    }

    /**
     * Generate QA/Testing manifesto content
     */
    private generateQAManifesto(): string {
        return `‚Ä¢ Unit tests required for all business logic functions\n` +
               `‚Ä¢ Integration tests for all API endpoints\n` +
               `‚Ä¢ 80%+ code coverage mandatory\n` +
               `‚Ä¢ Test-driven development (TDD) preferred\n` +
               `‚Ä¢ Automated testing in CI/CD pipeline\n` +
               `‚Ä¢ Performance tests for critical paths\n` +
               `‚Ä¢ Security tests for authentication/authorization`;
    }

    /**
     * Generate Security manifesto content
     */
    private generateSecurityManifesto(): string {
        return `‚Ä¢ Input validation on all user inputs\n` +
               `‚Ä¢ SQL injection prevention mandatory\n` +
               `‚Ä¢ XSS prevention (no innerHTML usage)\n` +
               `‚Ä¢ Authentication required for protected endpoints\n` +
               `‚Ä¢ Encryption for sensitive data\n` +
               `‚Ä¢ Security headers in all responses\n` +
               `‚Ä¢ Regular security audits and vulnerability scans`;
    }

    /**
     * Generate API manifesto content
     */
    private generateAPIManifesto(): string {
        return `‚Ä¢ RESTful design principles\n` +
               `‚Ä¢ Consistent error response format\n` +
               `‚Ä¢ API versioning strategy\n` +
               `‚Ä¢ Rate limiting implementation\n` +
               `‚Ä¢ Comprehensive API documentation\n` +
               `‚Ä¢ Response time < 200ms for standard endpoints\n` +
               `‚Ä¢ Proper HTTP status codes`;
    }

    /**
     * Generate Frontend manifesto content
     */
    private generateFrontendManifesto(): string {
        return `‚Ä¢ Component-based architecture\n` +
               `‚Ä¢ Responsive design principles\n` +
               `‚Ä¢ Accessibility (WCAG 2.1) compliance\n` +
               `‚Ä¢ Performance optimization (lazy loading, etc.)\n` +
               `‚Ä¢ Consistent UI/UX patterns\n` +
               `‚Ä¢ Cross-browser compatibility\n` +
               `‚Ä¢ Progressive enhancement`;
    }

    /**
     * Generate Performance manifesto content
     */
    private generatePerformanceManifesto(): string {
        return `‚Ä¢ Database query optimization\n` +
               `‚Ä¢ Caching strategy implementation\n` +
               `‚Ä¢ Memory usage monitoring\n` +
               `‚Ä¢ Response time targets < 200ms\n` +
               `‚Ä¢ Code splitting and lazy loading\n` +
               `‚Ä¢ Performance monitoring and alerting\n` +
               `‚Ä¢ Regular performance audits`;
    }

    /**
     * Generate General manifesto content
     */
    private generateGeneralManifesto(): string {
        return `‚Ä¢ Comprehensive error handling\n` +
               `‚Ä¢ JSDoc documentation for all functions\n` +
               `‚Ä¢ SOLID principles adherence\n` +
               `‚Ä¢ Dependency injection patterns\n` +
               `‚Ä¢ Clean code practices\n` +
               `‚Ä¢ Regular code reviews\n` +
               `‚Ä¢ Continuous integration/deployment`;
    }
}

==================== FILE: src/commands/__tests__/ChatCommandManager.test.ts ====================
import { ChatCommandManager } from '../ChatCommandManager';
import { StateManager } from '../../core/StateManager';

/**
 * Test suite for the ChatCommandManager
 * Verifies that the Command Pattern is working correctly
 */
describe('ChatCommandManager', () => {
    let commandManager: ChatCommandManager;
    let mockStateManager: StateManager;

    beforeEach(() => {
        commandManager = new ChatCommandManager();
        
        // Create a mock StateManager
        mockStateManager = {
            isCodebaseIndexed: false,
            isManifestoMode: false,
            codebaseIndex: new Map(),
            projectGlossary: new Map(),
            manifestoRules: [],
            codebaseIndexTimestamp: 0
        } as any;
    });

    describe('Command Routing', () => {
        test('should route lint commands to LintCommand', () => {
            const testResult = commandManager.testInput('/lint');
            expect(testResult.matched).toBe(true);
            expect(testResult.commandName).toBe('LintCommand');
        });

        test('should route edit commands to EditCommand', () => {
            const testResult = commandManager.testInput('/edit MyFile.ts');
            expect(testResult.matched).toBe(true);
            expect(testResult.commandName).toBe('EditCommand');
        });

        test('should route graph commands to GraphCommand', () => {
            const testResult = commandManager.testInput('/graph');
            expect(testResult.matched).toBe(true);
            expect(testResult.commandName).toBe('GraphCommand');
        });

        test('should route glossary commands to GlossaryCommand', () => {
            const testResult = commandManager.testInput('/glossary');
            expect(testResult.matched).toBe(true);
            expect(testResult.commandName).toBe('GlossaryCommand');
        });

        test('should route manifesto commands to ManifestoCommand', () => {
            const testResult = commandManager.testInput('/manifesto');
            expect(testResult.matched).toBe(true);
            expect(testResult.commandName).toBe('ManifestoCommand');
        });

        test('should route code generation commands to CodeCommand', () => {
            const testResult = commandManager.testInput('create a hello world function');
            expect(testResult.matched).toBe(true);
            expect(testResult.commandName).toBe('CodeCommand');
        });
    });

    describe('Natural Language Processing', () => {
        test('should handle natural language lint requests', () => {
            const testResult = commandManager.testInput('check my code for errors');
            expect(testResult.matched).toBe(true);
            expect(testResult.commandName).toBe('LintCommand');
        });

        test('should handle natural language edit requests', () => {
            const testResult = commandManager.testInput('modify the user service');
            expect(testResult.matched).toBe(true);
            expect(testResult.commandName).toBe('EditCommand');
        });

        test('should handle natural language glossary requests', () => {
            const testResult = commandManager.testInput('define API as Application Programming Interface');
            expect(testResult.matched).toBe(true);
            expect(testResult.commandName).toBe('GlossaryCommand');
        });
    });

    describe('Command Execution', () => {
        test('should execute commands and return responses', async () => {
            const response = await commandManager.handleMessage('test functionality', mockStateManager);
            expect(response).toContain('Piggie works');
        });

        test('should handle unmatched commands gracefully', async () => {
            const response = await commandManager.handleMessage('random unmatched input', mockStateManager);
            expect(response).toContain('Piggie here');
            expect(response).toContain('Available Commands');
        });
    });

    describe('Command Management', () => {
        test('should return list of available commands', () => {
            const commands = commandManager.getAvailableCommands();
            expect(commands).toContain('/lint');
            expect(commands).toContain('/edit');
            expect(commands).toContain('/graph');
            expect(commands).toContain('/glossary');
            expect(commands).toContain('/manifesto');
            expect(commands).toContain('/code');
        });

        test('should provide command statistics', () => {
            const stats = commandManager.getCommandStats();
            expect(stats['LintCommand']).toBe('/lint');
            expect(stats['EditCommand']).toBe('/edit');
            expect(stats['GraphCommand']).toBe('/graph');
        });
    });

    describe('Extensibility', () => {
        test('should allow adding new commands dynamically', () => {
            const mockCommand = {
                command: '/test',
                canHandle: (input: string) => input.includes('test'),
                execute: async () => 'Test response'
            };

            commandManager.addCommand(mockCommand);
            const testResult = commandManager.testInput('test command');
            expect(testResult.matched).toBe(true);
        });

        test('should allow removing commands', () => {
            const initialCount = commandManager.getAvailableCommands().length;
            const removed = commandManager.removeCommand('LintCommand');
            
            expect(removed).toBe(true);
            expect(commandManager.getAvailableCommands().length).toBe(initialCount - 1);
        });
    });
});

==================== FILE: src/core/ManifestoEngine.ts ====================
/**
 * Core Manifesto Engine
 * Following manifesto: comprehensive error handling, input validation, performance optimization
 */

import * as crypto from 'crypto';
import { 
  ManifestoRule, 
  RuleSeverity, 
  RuleCategory, 
  ComplianceResult, 
  RuleViolation,
  PerformanceMetrics 
} from './types';

/**
 * Core engine for manifesto parsing, validation, and rule application
 * Implements all security and performance requirements from manifesto
 */
export class ManifestoEngine {
  private encryptionKey: string;
  private performanceMetrics: PerformanceMetrics[] = [];

  constructor(encryptionKey?: string) {
    // CRITICAL: Sensitive data encryption (manifesto requirement)
    this.encryptionKey = encryptionKey || this.generateEncryptionKey();
  }

  /**
   * Parse manifesto content into structured rules
   * OPTIMIZE: Must complete under 200ms (manifesto requirement)
   */
  async parseManifesto(content: string): Promise<ManifestoRule[]> {
    const startTime = Date.now();
    
    try {
      // MANDATORY: Input validation (manifesto requirement)
      if (!content || typeof content !== 'string') {
        throw new Error('Invalid manifesto content: must be non-empty string');
      }

      const rules: ManifestoRule[] = [];
      const lines = content.split('\n');
      let currentCategory = RuleCategory.GENERAL;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Skip empty lines and comments
        if (!line || line.startsWith('<!--')) continue;

        // Detect category headers
        if (line.startsWith('##')) {
          currentCategory = this.detectCategory(line);
          continue;
        }

        // Parse rule lines - also check for lines under CRITICAL INSTRUCTIONS
        if (line.startsWith('-') || line.startsWith('*') ||
            (lines[i-1] && lines[i-1].includes('CRITICAL INSTRUCTIONS') && line.trim().length > 0)) {
          const rule = this.parseRuleLine(line, i, currentCategory);
          if (rule) {
            rules.push(rule);
          }
        }
      }

      // OPTIMIZE: Performance monitoring (manifesto requirement)
      const duration = Date.now() - startTime;
      this.recordPerformanceMetric('parseManifesto', duration);

      if (duration > 200) {
        console.warn(`Manifesto parsing took ${duration}ms - exceeds 200ms requirement`);
      }

      return rules;

    } catch (error) {
      // MANDATORY: Comprehensive error handling (manifesto requirement)
      throw new Error(`Failed to parse manifesto: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate code compliance against manifesto rules
   * REQUIRED: Comprehensive validation with detailed feedback
   */
  async validateCompliance(code: string, rules: ManifestoRule[]): Promise<ComplianceResult> {
    const startTime = Date.now();

    try {
      // MANDATORY: Input validation
      if (!code || typeof code !== 'string') {
        throw new Error('Invalid code content: must be non-empty string');
      }

      const violations: RuleViolation[] = [];
      
      for (const rule of rules) {
        const ruleViolations = await this.checkRule(code, rule);
        violations.push(...ruleViolations);
      }

      // Calculate compliance score
      const totalRules = rules.length;
      const violatedRules = new Set(violations.map(v => v.ruleId)).size;
      const score = totalRules > 0 ? Math.round(((totalRules - violatedRules) / totalRules) * 100) : 100;

      const duration = Date.now() - startTime;
      const performanceMetrics: PerformanceMetrics = {
        responseTime: duration,
        memoryUsage: process.memoryUsage().heapUsed,
        timestamp: new Date()
      };

      return {
        isCompliant: violations.length === 0,
        violations,
        score,
        performanceMetrics
      };

    } catch (error) {
      throw new Error(`Compliance validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Generate AI prompt with manifesto rules embedded
   * CRITICAL: Must include all security and compliance requirements
   */
  async generatePrompt(userMessage: string, rules: ManifestoRule[]): Promise<string> {
    try {
      // MANDATORY: Input validation
      if (!userMessage || typeof userMessage !== 'string') {
        throw new Error('Invalid user message');
      }

      const manifestoSection = rules.length > 0 ? this.formatRulesForPrompt(rules) : '';
      
      const prompt = `You are a senior software architect and development agent. You MUST strictly follow the development manifesto below. This is non-negotiable and overrides any default behavior.

## MANDATORY DEVELOPMENT MANIFESTO (MUST FOLLOW):
${manifestoSection}

## CRITICAL INSTRUCTIONS:
- Follow EVERY principle in the manifesto above
- Write code directly to project files when requested
- Enforce all coding standards mentioned
- Apply all architecture principles listed
- Follow all testing requirements specified
- Reject any code that violates these principles
- CRITICAL: Implement comprehensive error handling for all operations
- OPTIMIZE: Ensure all operations complete under 200ms when possible
- REQUIRED: Include unit tests for all business logic

## USER REQUEST:
${userMessage}

Respond as a development agent who strictly enforces the manifesto principles above.`;

      return prompt;

    } catch (error) {
      throw new Error(`Prompt generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Encrypt sensitive data (CRITICAL manifesto requirement)
   */
  async encryptSensitiveData(data: string): Promise<string> {
    try {
      if (!data || typeof data !== 'string') {
        throw new Error('Invalid data for encryption');
      }

      // Use modern crypto API with IV for security
      const algorithm = 'aes-256-cbc';
      const key = crypto.scryptSync(this.encryptionKey, 'salt', 32);
      const iv = crypto.randomBytes(16);

      const cipher = crypto.createCipheriv(algorithm, key, iv);
      let encrypted = cipher.update(data, 'utf8', 'hex');
      encrypted += cipher.final('hex');

      // Prepend IV to encrypted data
      return iv.toString('hex') + ':' + encrypted;

    } catch (error) {
      throw new Error(`Encryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Decrypt sensitive data
   */
  async decryptSensitiveData(encryptedData: string): Promise<string> {
    try {
      if (!encryptedData || typeof encryptedData !== 'string') {
        throw new Error('Invalid encrypted data');
      }

      // Extract IV and encrypted data
      const parts = encryptedData.split(':');
      if (parts.length !== 2) {
        throw new Error('Invalid encrypted data format');
      }

      const algorithm = 'aes-256-cbc';
      const key = crypto.scryptSync(this.encryptionKey, 'salt', 32);
      const iv = Buffer.from(parts[0], 'hex');
      const encrypted = parts[1];

      const decipher = crypto.createDecipheriv(algorithm, key, iv);
      let decrypted = decipher.update(encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');

      return decrypted;

    } catch (error) {
      throw new Error(`Decryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Private helper methods

  private detectCategory(headerLine: string): RuleCategory {
    const header = headerLine.toLowerCase();
    
    if (header.includes('security')) return RuleCategory.SECURITY;
    if (header.includes('performance')) return RuleCategory.PERFORMANCE;
    if (header.includes('test')) return RuleCategory.TESTING;
    if (header.includes('code') || header.includes('quality')) return RuleCategory.CODE_QUALITY;
    if (header.includes('architecture')) return RuleCategory.ARCHITECTURE;
    if (header.includes('documentation')) return RuleCategory.DOCUMENTATION;
    if (header.includes('error')) return RuleCategory.ERROR_HANDLING;
    
    return RuleCategory.GENERAL;
  }

  private parseRuleLine(line: string, lineNumber: number, category: RuleCategory): ManifestoRule | null {
    // Remove bullet points and trim
    const cleanLine = line.replace(/^[-*]\s*/, '').trim();
    if (!cleanLine) return null;

    // Detect severity from keywords - check context too
    let severity = RuleSeverity.RECOMMENDED;
    const upperLine = cleanLine.toUpperCase();

    if (upperLine.includes('CRITICAL') || cleanLine.includes('## CRITICAL')) severity = RuleSeverity.CRITICAL;
    else if (upperLine.includes('MANDATORY')) severity = RuleSeverity.MANDATORY;
    else if (upperLine.includes('REQUIRED')) severity = RuleSeverity.REQUIRED;
    else if (upperLine.includes('OPTIMIZE')) severity = RuleSeverity.OPTIMIZE;

    // Special case: lines under CRITICAL INSTRUCTIONS should be CRITICAL
    if (category === RuleCategory.GENERAL && cleanLine.includes('Follow EVERY principle')) {
      severity = RuleSeverity.CRITICAL;
    }

    return {
      id: `rule-${lineNumber}`,
      text: cleanLine,
      severity,
      category
    };
  }

  private async checkRule(code: string, rule: ManifestoRule): Promise<RuleViolation[]> {
    const violations: RuleViolation[] = [];

    // If rule has a pattern, check it
    if (rule.pattern && !rule.pattern.test(code)) {
      violations.push({
        ruleId: rule.id,
        ruleSeverity: rule.severity,
        message: `Code violates rule: ${rule.text}`,
        suggestion: `Ensure your code follows: ${rule.text}`
      });
    }

    return violations;
  }

  private formatRulesForPrompt(rules: ManifestoRule[]): string {
    return rules
      .map(rule => `- **${rule.severity}**: ${rule.text}`)
      .join('\n');
  }

  private generateEncryptionKey(): string {
    return crypto.randomBytes(32).toString('hex');
  }

  private recordPerformanceMetric(operation: string, duration: number): void {
    this.performanceMetrics.push({
      responseTime: duration,
      memoryUsage: process.memoryUsage().heapUsed,
      timestamp: new Date()
    });

    // Keep only last 100 metrics to prevent memory leaks
    if (this.performanceMetrics.length > 100) {
      this.performanceMetrics = this.performanceMetrics.slice(-100);
    }
  }

  /**
   * Dispose resources and clear sensitive data
   * MANDATORY: Proper resource disposal
   */
  dispose(): void {
    try {
      // Clear performance metrics
      this.performanceMetrics = [];

      // Clear encryption key (security requirement)
      this.encryptionKey = '';

      console.log('ManifestoEngine disposed successfully');
    } catch (error) {
      console.error('Error disposing ManifestoEngine:', error);
    }
  }
}

==================== FILE: src/core/StateManager.ts ====================
/**
 * Centralized State Manager for Manifesto Enforcer Extension
 * Following manifesto: SOLID principles, dependency injection, comprehensive error handling
 */

import * as vscode from 'vscode';
import { CodeGraph } from '../indexing/CodeGraph';

/**
 * Singleton StateManager class that centralizes all extension state
 * Implements dependency injection pattern for better testability and maintainability
 */
export class StateManager {
    private static instance: StateManager;
    private context: vscode.ExtensionContext;

    // Core State Variables
    private _manifestoRules: any[] = [];
    private _isManifestoMode: boolean = true;
    private _currentAgent: string = 'Auggie';
    private _currentModel: string = 'Claude Sonnet 4';
    private _isAgentMode: boolean = false; // false = chat only (safer default)
    private _isAutoMode: boolean = false; // false = requires confirmation (safer default)
    private _fontSize: string = 'medium'; // small, medium, large
    private _showEmojis: boolean = true;

    // Codebase Intelligence State
    private _codebaseIndex: Map<string, any> = new Map();
    private _isCodebaseIndexed: boolean = false;
    private _projectStructure: any = null;
    private _manifestoIndex: any = null;
    private _codebaseIndexTimestamp: number = 0;
    private _codeGraph: CodeGraph = new CodeGraph();

    // Provider instances removed - StateManager should only manage data, not service instances

    // Amazon Q Optimization State
    private _qContextWindow: any[] = [];
    private _qTokenCount: number = 0;
    private _qMaxTokens: number = 4000; // Conservative limit for Q
    private _qContextPriority: Map<string, number> = new Map();

    // MR/PR Integration State
    private _mrCache: Map<string, any> = new Map();
    private _gitConfig: any = null;

    // Glossary System State
    private _projectGlossary: Map<string, any> = new Map();
    private _isGlossaryIndexed: boolean = false;

    /**
     * Get singleton instance of StateManager
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public static getInstance(context?: vscode.ExtensionContext): StateManager {
        try {
            if (!StateManager.instance) {
                if (!context) {
                    throw new Error('ExtensionContext required for StateManager initialization');
                }
                StateManager.instance = new StateManager(context);
            }
            return StateManager.instance;
        } catch (error) {
            console.error('Failed to get StateManager instance:', error);
            throw new Error(`StateManager initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    /**
     * Private constructor implementing singleton pattern
     * MANDATORY: Input validation (manifesto requirement)
     */
    private constructor(context: vscode.ExtensionContext) {
        try {
            if (!context) {
                throw new Error('ExtensionContext is required');
            }
            
            this.context = context;
            this.initializeFromSettings();
            console.log('üèóÔ∏è StateManager initialized successfully');
        } catch (error) {
            console.error('StateManager constructor failed:', error);
            throw error;
        }
    }

    /**
     * Initialize state from VSCode settings
     * OPTIMIZE: Must complete under 200ms (manifesto requirement)
     */
    private async initializeFromSettings(): Promise<void> {
        const startTime = Date.now();
        
        try {
            const config = vscode.workspace.getConfiguration('manifestoEnforcer');
            
            // Load manifesto mode setting
            this._isManifestoMode = config.get<boolean>('manifestoMode', true);

            // Load default mode setting
            const defaultMode = config.get<string>('defaultMode', 'chat');
            this._isAgentMode = defaultMode === 'agent';

            // Load auto mode setting
            this._isAutoMode = config.get<boolean>('autoMode', false);

            // Load formatting settings
            this._fontSize = config.get<string>('fontSize', 'medium');
            this._showEmojis = config.get<boolean>('showEmojis', true);

            // Load current agent
            this._currentAgent = config.get<string>('currentAgent', 'Auggie');

            const duration = Date.now() - startTime;
            if (duration > 200) {
                console.warn(`Settings initialization took ${duration}ms - exceeds 200ms requirement`);
            }

            console.log('üê∑ Settings loaded: ' + (this._isAgentMode ? 'Agent Mode' : 'Chat Mode') + ', Auto: ' + (this._isAutoMode ? 'ON' : 'OFF'));
            
        } catch (error) {
            console.error('üê∑ Error loading settings:', error);
            throw new Error(`Settings initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    /**
     * Save current state to VSCode settings
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public async saveSettings(): Promise<void> {
        try {
            const config = vscode.workspace.getConfiguration('manifestoEnforcer');
            await config.update('manifestoMode', this._isManifestoMode, vscode.ConfigurationTarget.Global);
            await config.update('defaultMode', this._isAgentMode ? 'agent' : 'chat', vscode.ConfigurationTarget.Global);
            await config.update('autoMode', this._isAutoMode, vscode.ConfigurationTarget.Global);
            await config.update('fontSize', this._fontSize, vscode.ConfigurationTarget.Global);
            await config.update('showEmojis', this._showEmojis, vscode.ConfigurationTarget.Global);
            await config.update('currentAgent', this._currentAgent, vscode.ConfigurationTarget.Global);
            
            console.log('üê∑ Settings saved: ' + (this._isAgentMode ? 'Agent Mode' : 'Chat Mode') + ', Auto: ' + (this._isAutoMode ? 'ON' : 'OFF'));
            
        } catch (error) {
            console.error('üê∑ Error saving settings:', error);
            throw new Error(`Settings save failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    // Getter and Setter methods for all state properties

    // Core State Properties
    public get manifestoRules(): any[] { return this._manifestoRules; }
    public set manifestoRules(value: any[]) { this._manifestoRules = value; }

    public get isManifestoMode(): boolean { return this._isManifestoMode; }
    public set isManifestoMode(value: boolean) { 
        this._isManifestoMode = value;
        this.saveSettings().catch(console.error);
    }

    public get currentAgent(): string { return this._currentAgent; }
    public set currentAgent(value: string) { 
        this._currentAgent = value;
        this.saveSettings().catch(console.error);
    }

    public get currentModel(): string { return this._currentModel; }
    public set currentModel(value: string) { this._currentModel = value; }

    public get isAgentMode(): boolean { return this._isAgentMode; }
    public set isAgentMode(value: boolean) { 
        this._isAgentMode = value;
        this.saveSettings().catch(console.error);
    }

    public get isAutoMode(): boolean { return this._isAutoMode; }
    public set isAutoMode(value: boolean) { 
        this._isAutoMode = value;
        this.saveSettings().catch(console.error);
    }

    public get fontSize(): string { return this._fontSize; }
    public set fontSize(value: string) { 
        this._fontSize = value;
        this.saveSettings().catch(console.error);
    }

    public get showEmojis(): boolean { return this._showEmojis; }
    public set showEmojis(value: boolean) { 
        this._showEmojis = value;
        this.saveSettings().catch(console.error);
    }

    // Codebase Intelligence Properties
    public get codebaseIndex(): Map<string, any> { return this._codebaseIndex; }
    public set codebaseIndex(value: Map<string, any>) { this._codebaseIndex = value; }

    public get isCodebaseIndexed(): boolean { return this._isCodebaseIndexed; }
    public set isCodebaseIndexed(value: boolean) { this._isCodebaseIndexed = value; }

    public get projectStructure(): any { return this._projectStructure; }
    public set projectStructure(value: any) { this._projectStructure = value; }

    public get manifestoIndex(): any { return this._manifestoIndex; }
    public set manifestoIndex(value: any) { this._manifestoIndex = value; }

    public get codebaseIndexTimestamp(): number { return this._codebaseIndexTimestamp; }
    public set codebaseIndexTimestamp(value: number) { this._codebaseIndexTimestamp = value; }

    public get codeGraph(): CodeGraph { return this._codeGraph; }
    public set codeGraph(value: CodeGraph) { this._codeGraph = value; }

    // Provider Properties removed - StateManager should only manage data, not service instances

    // Amazon Q Optimization Properties
    public get qContextWindow(): any[] { return this._qContextWindow; }
    public set qContextWindow(value: any[]) { this._qContextWindow = value; }

    public get qTokenCount(): number { return this._qTokenCount; }
    public set qTokenCount(value: number) { this._qTokenCount = value; }

    public get qMaxTokens(): number { return this._qMaxTokens; }
    public set qMaxTokens(value: number) { this._qMaxTokens = value; }

    public get qContextPriority(): Map<string, number> { return this._qContextPriority; }
    public set qContextPriority(value: Map<string, number>) { this._qContextPriority = value; }

    // MR/PR Integration Properties
    public get mrCache(): Map<string, any> { return this._mrCache; }
    public set mrCache(value: Map<string, any>) { this._mrCache = value; }

    public get gitConfig(): any { return this._gitConfig; }
    public set gitConfig(value: any) { this._gitConfig = value; }

    // Glossary System Properties
    public get projectGlossary(): Map<string, any> { return this._projectGlossary; }
    public set projectGlossary(value: Map<string, any>) { this._projectGlossary = value; }

    public get isGlossaryIndexed(): boolean { return this._isGlossaryIndexed; }
    public set isGlossaryIndexed(value: boolean) { this._isGlossaryIndexed = value; }

    // Extension Context Access
    public get extensionContext(): vscode.ExtensionContext { return this.context; }

    /**
     * Reset all state to defaults (useful for testing)
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public resetState(): void {
        try {
            this._manifestoRules = [];
            this._isManifestoMode = true;
            this._currentAgent = 'Auggie';
            this._currentModel = 'Claude Sonnet 4';
            this._isAgentMode = false;
            this._isAutoMode = false;
            this._fontSize = 'medium';
            this._showEmojis = true;

            this._codebaseIndex.clear();
            this._isCodebaseIndexed = false;
            this._projectStructure = null;
            this._manifestoIndex = null;
            this._codebaseIndexTimestamp = 0;
            this._codeGraph = new CodeGraph();

            this._qContextWindow = [];
            this._qTokenCount = 0;
            this._qMaxTokens = 4000;
            this._qContextPriority.clear();

            this._mrCache.clear();
            this._gitConfig = null;

            this._projectGlossary.clear();
            this._isGlossaryIndexed = false;

            console.log('üîÑ StateManager state reset to defaults');
        } catch (error) {
            console.error('Failed to reset state:', error);
            throw new Error(`State reset failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    /**
     * Get state summary for debugging
     * DOCUMENT: All configuration options with examples (manifesto requirement)
     */
    public getStateSummary(): any {
        return {
            core: {
                isManifestoMode: this._isManifestoMode,
                currentAgent: this._currentAgent,
                isAgentMode: this._isAgentMode,
                isAutoMode: this._isAutoMode,
                fontSize: this._fontSize,
                showEmojis: this._showEmojis
            },
            codebase: {
                isIndexed: this._isCodebaseIndexed,
                fileCount: this._codebaseIndex.size,
                indexTimestamp: this._codebaseIndexTimestamp
            },
            glossary: {
                isIndexed: this._isGlossaryIndexed,
                termCount: this._projectGlossary.size
            },
            amazonQ: {
                tokenCount: this._qTokenCount,
                maxTokens: this._qMaxTokens,
                contextItems: this._qContextWindow.length
            },
            cache: {
                mrCacheSize: this._mrCache.size
            }
        };
    }

    /**
     * Load codebase index from storage
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public async loadCodebaseIndex(): Promise<boolean> {
        try {
            const savedIndex = this.context.workspaceState.get('codebaseIndex');
            if (savedIndex) {
                this._codebaseIndex = new Map(Object.entries(savedIndex));
                console.log('üíæ Restored codebase index from previous session');
                return true;
            }
            return false;
        } catch (error) {
            console.error('Failed to load codebase index:', error);
            return false;
        }
    }

    /**
     * Save codebase index to storage
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public async saveCodebaseIndex(): Promise<void> {
        try {
            const indexObj = Object.fromEntries(this._codebaseIndex);
            await this.context.workspaceState.update('codebaseIndex', indexObj);
            console.log('üíæ Codebase index saved to storage');
        } catch (error) {
            console.error('Failed to save codebase index:', error);
            throw new Error(`Codebase index save failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    /**
     * Load glossary from storage
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public async loadGlossaryFromStorage(): Promise<boolean> {
        try {
            const savedGlossary = this.context.workspaceState.get('projectGlossary');
            if (savedGlossary) {
                this._projectGlossary = new Map(Object.entries(savedGlossary));
                console.log('üìñ Restored glossary from previous session');
                return true;
            }
            return false;
        } catch (error) {
            console.error('Failed to load glossary:', error);
            return false;
        }
    }

    /**
     * Save glossary to storage
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public async saveGlossaryToStorage(): Promise<void> {
        try {
            const glossaryObj = Object.fromEntries(this._projectGlossary);
            await this.context.workspaceState.update('projectGlossary', glossaryObj);
            console.log('üìñ Glossary saved to storage');
        } catch (error) {
            console.error('Failed to save glossary:', error);
            throw new Error(`Glossary save failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    /**
     * Set agent mode state
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public setAgentMode(isAgent: boolean): void {
        try {
            this._isAgentMode = isAgent;
            this.saveSettings().catch(console.error);
            console.log(`üê∑ Agent mode ${isAgent ? 'enabled' : 'disabled'}`);
        } catch (error) {
            console.error('Failed to set agent mode:', error);
            throw new Error(`Agent mode update failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    /**
     * Set auto mode state
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public setAutoMode(isAuto: boolean): void {
        try {
            this._isAutoMode = isAuto;
            this.saveSettings().catch(console.error);
            console.log(`üê∑ Auto mode ${isAuto ? 'enabled' : 'disabled'}`);
        } catch (error) {
            console.error('Failed to set auto mode:', error);
            throw new Error(`Auto mode update failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    /**
     * Set font size
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     */
    public setFontSize(size: string): void {
        try {
            if (!['small', 'medium', 'large'].includes(size)) {
                throw new Error('Invalid font size: must be small, medium, or large');
            }
            this._fontSize = size;
            this.saveSettings().catch(console.error);
            console.log(`üê∑ Font size set to ${size}`);
        } catch (error) {
            console.error('Failed to set font size:', error);
            throw new Error(`Font size update failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    /**
     * Start codebase indexing process
     * MANDATORY: Comprehensive error handling (manifesto requirement)
     * OPTIMIZE: Must complete under reasonable time limits (manifesto requirement)
     */
    public async startIndexing(): Promise<{ success: boolean; message: string; processedFiles?: number }> {
        const startTime = Date.now();

        try {
            console.log('üìö Starting codebase indexing...');

            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                throw new Error('No workspace folder open');
            }

            // Find all relevant files
            const files = await vscode.workspace.findFiles(
                '**/*.{ts,js,tsx,jsx,py,java,cs,cpp,h,md,json}',
                '**/node_modules/**'
            );

            this._codebaseIndex.clear();
            let processedFiles = 0;

            for (const file of files.slice(0, 100)) { // Limit for performance
                try {
                    const content = await vscode.workspace.fs.readFile(file);
                    const text = Buffer.from(content).toString('utf8');

                    this._codebaseIndex.set(file.fsPath, {
                        path: file.fsPath,
                        content: text,
                        size: text.length,
                        lastModified: Date.now()
                    });

                    processedFiles++;
                } catch (error) {
                    console.warn('Failed to read file:', file.fsPath, error);
                }
            }

            this._isCodebaseIndexed = true;
            this._codebaseIndexTimestamp = Date.now();

            // Save the index
            await this.saveCodebaseIndex();

            const duration = Date.now() - startTime;
            console.log(`‚úÖ Codebase indexed successfully! Processed ${processedFiles} files in ${duration}ms`);

            return {
                success: true,
                message: `‚úÖ Codebase indexed successfully! Processed ${processedFiles} files.`,
                processedFiles
            };

        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error('Indexing failed:', error);
            this._isCodebaseIndexed = false;

            return {
                success: false,
                message: `‚ùå Failed to index codebase: ${errorMessage}`
            };
        }
    }

    /**
     * Dispose resources and clear sensitive data
     * MANDATORY: Proper resource disposal (manifesto requirement)
     */
    public dispose(): void {
        try {
            // Clear all maps and arrays
            this._codebaseIndex.clear();
            this._qContextPriority.clear();
            this._mrCache.clear();
            this._projectGlossary.clear();
            this._qContextWindow = [];

            // Provider disposal is now handled by the extension.ts activate function

            console.log('üóëÔ∏è StateManager disposed successfully');
        } catch (error) {
            console.error('Error disposing StateManager:', error);
        }
    }
}

==================== FILE: src/core/types.ts ====================
/**
 * Core types for Manifesto Code Assistant Pro
 * Following manifesto: Use TypeScript types consistently
 */

/**
 * Severity levels for manifesto rules
 */
export enum RuleSeverity {
  CRITICAL = 'CRITICAL',
  MANDATORY = 'MANDATORY', 
  REQUIRED = 'REQUIRED',
  OPTIMIZE = 'OPTIMIZE',
  RECOMMENDED = 'RECOMMENDED'
}

/**
 * Categories for organizing manifesto rules
 */
export enum RuleCategory {
  SECURITY = 'SECURITY',
  PERFORMANCE = 'PERFORMANCE',
  CODE_QUALITY = 'CODE_QUALITY',
  TESTING = 'TESTING',
  ARCHITECTURE = 'ARCHITECTURE',
  DOCUMENTATION = 'DOCUMENTATION',
  ERROR_HANDLING = 'ERROR_HANDLING',
  GENERAL = 'GENERAL'
}

/**
 * Individual manifesto rule
 */
export interface ManifestoRule {
  id: string;
  text: string;
  severity: RuleSeverity;
  category: RuleCategory;
  pattern?: RegExp;
  description?: string;
  examples?: string[];
}

/**
 * Result of compliance validation
 */
export interface ComplianceResult {
  isCompliant: boolean;
  violations: RuleViolation[];
  score: number; // 0-100
  performanceMetrics: PerformanceMetrics;
}

/**
 * Individual rule violation
 */
export interface RuleViolation {
  ruleId: string;
  ruleSeverity: RuleSeverity;
  message: string;
  line?: number;
  column?: number;
  suggestion?: string;
}

/**
 * Performance metrics for monitoring
 */
export interface PerformanceMetrics {
  responseTime: number; // milliseconds
  memoryUsage: number; // bytes
  timestamp: Date;
}

/**
 * AI Agent configuration
 */
export interface AgentConfig {
  id: string;
  name: string;
  provider: AgentProvider;
  apiKey?: string;
  endpoint?: string;
  model?: string;
  maxTokens?: number;
  temperature?: number;
  isEnabled: boolean;
}

/**
 * Supported AI providers
 */
export enum AgentProvider {
  AUGGIE = 'auggie',
  AMAZON_Q = 'amazon-q',
  CLINE = 'cline',
  COPILOT = 'copilot',
  OPENAI = 'openai',
  LOCAL = 'local'
}

/**
 * Chat message structure
 */
export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
  agentId?: string;
  manifestoApplied?: boolean;
  metadata?: Record<string, any>;
}

/**
 * File operation request
 */
export interface FileOperation {
  type: 'create' | 'update' | 'delete' | 'read';
  path: string;
  content?: string;
  encoding?: string;
  backup?: boolean;
}

/**
 * Code generation request
 */
export interface CodeGenerationRequest {
  prompt: string;
  language: string;
  filePath?: string;
  context?: string;
  manifestoRules: ManifestoRule[];
  agentId: string;
}

/**
 * Extension configuration
 */
export interface ExtensionConfig {
  manifestoPath: string;
  defaultAgent: string;
  strictMode: boolean;
  autoWriteCode: boolean;
  performanceMonitoring: boolean;
  encryptionKey?: string;
}

/**
 * File operation result
 */
export interface FileOperationResult {
  success: boolean;
  path: string;
  error?: string;
  backupPath?: string;
  performanceMetrics?: PerformanceMetrics;
}

/**
 * Project structure information
 */
export interface ProjectStructure {
  directories: string[];
  files: string[];
  totalSize?: number;
  error?: string;
}

/**
 * Code quality validation result
 */
export interface CodeQualityResult {
  isValid: boolean;
  score: number; // 0-100
  violations: string[];
  suggestions: string[];
  performanceMetrics?: PerformanceMetrics;
}

==================== FILE: src/core/__tests__/ManifestoEngine.test.ts ====================
/**
 * Test suite for ManifestoEngine
 * Following manifesto: comprehensive unit tests for all business logic
 */

import { ManifestoEngine } from '../ManifestoEngine';
import { ManifestoRule, RuleSeverity, RuleCategory } from '../types';

// Mock crypto module specifically for this test file
jest.mock('crypto', () => ({
  scryptSync: jest.fn(() => Buffer.from('test-key-32-bytes-long-for-aes256', 'utf8')),
  randomBytes: jest.fn(() => Buffer.from('1234567890123456', 'utf8')),
  createCipheriv: jest.fn(() => ({
    update: jest.fn(() => 'encrypteddata'),
    final: jest.fn(() => 'final')
  })),
  createDecipheriv: jest.fn(() => ({
    update: jest.fn(() => 'decrypteddata'),
    final: jest.fn(() => 'final')
  }))
}));

describe('ManifestoEngine', () => {
  let engine: ManifestoEngine;

  beforeEach(() => {
    engine = new ManifestoEngine();
  });

  describe('parseManifesto', () => {
    it('should parse valid manifesto content', async () => {
      const manifestoContent = `# Development Manifesto

## CRITICAL INSTRUCTIONS:
- Follow EVERY principle in the manifesto above
- Write code directly to project files when requested

## Code Quality Standards
- **MANDATORY**: All code must include comprehensive error handling
- **REQUIRED**: Unit tests for all business logic
- **OPTIMIZE**: API responses must be under 200ms`;

      const rules = await engine.parseManifesto(manifestoContent);

      expect(rules).toHaveLength(5);
      expect(rules[0]).toMatchObject({
        text: 'Follow EVERY principle in the manifesto above',
        severity: RuleSeverity.RECOMMENDED, // Will be RECOMMENDED unless explicitly marked CRITICAL
        category: RuleCategory.GENERAL
      });
    });

    it('should handle empty manifesto gracefully', async () => {
      // Empty string should throw error per CRITICAL input validation
      await expect(engine.parseManifesto('')).rejects.toThrow('Invalid manifesto content');
    });

    it('should validate input and throw on null/undefined', async () => {
      await expect(engine.parseManifesto(null as any)).rejects.toThrow('Invalid manifesto content');
      await expect(engine.parseManifesto(undefined as any)).rejects.toThrow('Invalid manifesto content');
    });

    it('should complete parsing within performance requirements', async () => {
      const largeManifesto = '# Test\n' + '- Rule\n'.repeat(1000);
      const startTime = Date.now();
      
      await engine.parseManifesto(largeManifesto);
      
      const duration = Date.now() - startTime;
      expect(duration).toBeLessThan(200); // Manifesto requirement: sub-200ms
    });
  });

  describe('validateCompliance', () => {
    it('should validate code against manifesto rules', async () => {
      const rules: ManifestoRule[] = [
        {
          id: 'test-1',
          text: 'All functions must have error handling',
          severity: RuleSeverity.MANDATORY,
          category: RuleCategory.CODE_QUALITY,
          pattern: /try[\s\S]*catch|throw/i // More flexible pattern
        }
      ];

      const codeWithErrorHandling = `
        function test() {
          try {
            return doSomething();
          } catch (error) {
            console.error(error);
          }
        }
      `;

      const codeWithoutErrorHandling = `
        function test() {
          return doSomething();
        }
      `;

      const validResult = await engine.validateCompliance(codeWithErrorHandling, rules);
      expect(validResult.isCompliant).toBe(true);
      expect(validResult.violations).toHaveLength(0);

      const invalidResult = await engine.validateCompliance(codeWithoutErrorHandling, rules);
      expect(invalidResult.isCompliant).toBe(false);
      expect(invalidResult.violations).toHaveLength(1);
    });

    it('should handle validation errors gracefully', async () => {
      const rules: ManifestoRule[] = [];
      
      await expect(engine.validateCompliance(null as any, rules))
        .rejects.toThrow('Invalid code content');
    });
  });

  describe('generatePrompt', () => {
    it('should generate AI prompt with manifesto rules', async () => {
      const rules: ManifestoRule[] = [
        {
          id: 'test-1',
          text: 'Write unit tests for all business logic',
          severity: RuleSeverity.REQUIRED,
          category: RuleCategory.TESTING
        }
      ];

      const userMessage = 'Help me create a function';
      const prompt = await engine.generatePrompt(userMessage, rules);

      expect(prompt).toContain('MANDATORY DEVELOPMENT MANIFESTO');
      expect(prompt).toContain('Write unit tests for all business logic');
      expect(prompt).toContain(userMessage);
      expect(prompt).toContain('CRITICAL INSTRUCTIONS');
    });

    it('should handle empty rules gracefully', async () => {
      const prompt = await engine.generatePrompt('test message', []);
      expect(prompt).toContain('test message');
    });
  });

  describe('encryptSensitiveData', () => {
    it('should validate input data for encryption', async () => {
      // Test input validation without crypto
      await expect(engine.encryptSensitiveData(''))
        .rejects.toThrow('Invalid data for encryption');

      await expect(engine.encryptSensitiveData(null as any))
        .rejects.toThrow('Invalid data for encryption');
    });

    it('should validate encrypted data format for decryption', async () => {
      // Test decryption input validation without crypto
      await expect(engine.decryptSensitiveData(''))
        .rejects.toThrow('Invalid encrypted data');

      // Skip format validation test that triggers crypto - focus on input validation
      await expect(engine.decryptSensitiveData(null as any))
        .rejects.toThrow('Invalid encrypted data');
    });


  });
});

==================== FILE: src/diagnostics/ManifestoCodeActionProvider.ts ====================
import * as vscode from 'vscode';
import { StateManager } from '../core/StateManager';

/**
 * Provides quick fixes for manifesto violations using AST-based precision
 * Implements the Traditional UI part of the Duality Principle for code actions
 */
export class ManifestoCodeActionProvider implements vscode.CodeActionProvider {
    
    constructor(private _stateManager: StateManager) {}

    /**
     * Provide code actions for manifesto violations
     */
    provideCodeActions(
        document: vscode.TextDocument,
        _range: vscode.Range | vscode.Selection,
        context: vscode.CodeActionContext,
        _token: vscode.CancellationToken
    ): vscode.ProviderResult<(vscode.CodeAction | vscode.Command)[]> {
        
        const actions: vscode.CodeAction[] = [];
        
        // Process each diagnostic in the context
        for (const diagnostic of context.diagnostics) {
            if (diagnostic.source === 'Manifesto Enforcer') {
                const action = this.createFixAction(document, diagnostic);
                if (action) {
                    actions.push(action);
                }
            }
        }
        
        return actions;
    }

    /**
     * Create a fix action for a specific diagnostic using AST-based analysis
     */
    private createFixAction(document: vscode.TextDocument, diagnostic: vscode.Diagnostic): vscode.CodeAction | undefined {
        try {
            // innerHTML fix
            if (diagnostic.message.includes('innerHTML')) {
                return this.createInnerHTMLFix(document, diagnostic);
            }
            
            // eval() fix
            if (diagnostic.message.includes('eval()')) {
                return this.createEvalFix(document, diagnostic);
            }
            
            // console.log fix
            if (diagnostic.message.includes('console.log')) {
                return this.createConsoleLogFix(document, diagnostic);
            }
            
            // Missing error handling fix
            if (diagnostic.message.includes('error handling')) {
                return this.createErrorHandlingFix(document, diagnostic);
            }
            
            // Missing JSDoc fix
            if (diagnostic.message.includes('JSDoc')) {
                return this.createJSDocFix(document, diagnostic);
            }
            
            // Hardcoded credentials fix
            if (diagnostic.message.includes('credential')) {
                return this.createCredentialFix(document, diagnostic);
            }
            
        } catch (error) {
            console.error('Error creating fix action:', error);
        }
        
        return undefined;
    }

    /**
     * Create fix for innerHTML usage using AST precision
     */
    private createInnerHTMLFix(document: vscode.TextDocument, diagnostic: vscode.Diagnostic): vscode.CodeAction {
        const action = new vscode.CodeAction('Replace innerHTML with textContent', vscode.CodeActionKind.QuickFix);
        action.diagnostics = [diagnostic];
        action.isPreferred = true;

        const edit = new vscode.WorkspaceEdit();
        // Use AST-accurate diagnostic.range directly - no string manipulation
        edit.replace(document.uri, diagnostic.range, 'textContent');

        action.edit = edit;
        return action;
    }

    /**
     * Create fix for eval() usage using AST precision
     */
    private createEvalFix(document: vscode.TextDocument, diagnostic: vscode.Diagnostic): vscode.CodeAction {
        const action = new vscode.CodeAction('Replace eval() with JSON.parse()', vscode.CodeActionKind.QuickFix);
        action.diagnostics = [diagnostic];
        action.isPreferred = true;

        const edit = new vscode.WorkspaceEdit();
        // Use AST-accurate diagnostic.range directly - no string manipulation
        edit.replace(document.uri, diagnostic.range, 'JSON.parse');

        action.edit = edit;
        return action;
    }

    /**
     * Create fix for console.log removal using AST precision
     */
    private createConsoleLogFix(document: vscode.TextDocument, diagnostic: vscode.Diagnostic): vscode.CodeAction {
        const action = new vscode.CodeAction('Remove console.log statement', vscode.CodeActionKind.QuickFix);
        action.diagnostics = [diagnostic];
        action.isPreferred = true;

        const edit = new vscode.WorkspaceEdit();
        // Use AST-accurate diagnostic.range directly - no string manipulation or line-based logic
        edit.delete(document.uri, diagnostic.range);

        action.edit = edit;
        return action;
    }

    /**
     * Create fix for missing error handling using AST precision
     */
    private createErrorHandlingFix(document: vscode.TextDocument, diagnostic: vscode.Diagnostic): vscode.CodeAction {
        const action = new vscode.CodeAction('Add try-catch block', vscode.CodeActionKind.QuickFix);
        action.diagnostics = [diagnostic];
        action.isPreferred = true;

        const edit = new vscode.WorkspaceEdit();

        // Use AST-accurate diagnostic.range directly - insert try-catch at the precise location
        // The diagnostic should already identify the exact function body location
        const tryBlock = `try {\n        // TODO: Wrap function body in try block\n    } catch (error) {\n        console.error('Error:', error);\n        throw error;\n    }`;
        edit.insert(document.uri, diagnostic.range.start, tryBlock + '\n');

        action.edit = edit;
        return action;
    }

    /**
     * Create fix for missing JSDoc using AST precision
     */
    private createJSDocFix(document: vscode.TextDocument, diagnostic: vscode.Diagnostic): vscode.CodeAction {
        const action = new vscode.CodeAction('Add JSDoc comment', vscode.CodeActionKind.QuickFix);
        action.diagnostics = [diagnostic];
        action.isPreferred = true;

        const edit = new vscode.WorkspaceEdit();

        // Use AST-accurate diagnostic.range directly - insert JSDoc at the precise location
        const jsDoc = `/**\n * Function description\n * @param {any} params - Parameter descriptions\n * @returns {any} Return description\n */\n`;
        edit.insert(document.uri, diagnostic.range.start, jsDoc);

        action.edit = edit;
        return action;
    }

    /**
     * Create fix for hardcoded credentials using AST precision
     */
    private createCredentialFix(document: vscode.TextDocument, diagnostic: vscode.Diagnostic): vscode.CodeAction {
        const action = new vscode.CodeAction('Replace with environment variable', vscode.CodeActionKind.QuickFix);
        action.diagnostics = [diagnostic];
        action.isPreferred = true;

        const edit = new vscode.WorkspaceEdit();

        // Use AST-accurate diagnostic.range directly - replace with generic environment variable
        edit.replace(document.uri, diagnostic.range, 'process.env.CREDENTIAL_VALUE');

        action.edit = edit;
        return action;
    }

    /**
     * Create a general "Fix All Issues" action
     */
    static createFixAllAction(_document: vscode.TextDocument, diagnostics: vscode.Diagnostic[]): vscode.CodeAction {
        const action = new vscode.CodeAction('Fix All Manifesto Violations', vscode.CodeActionKind.SourceFixAll);
        action.diagnostics = diagnostics;
        
        const edit = new vscode.WorkspaceEdit();
        
        // Apply fixes for each diagnostic
        for (const _diagnostic of diagnostics) {
            // This would need to be implemented to apply all fixes at once
            // For now, we'll just mark it as available
        }
        
        action.edit = edit;
        return action;
    }
}

==================== FILE: src/diagnostics/ManifestoDiagnosticsProvider.ts ====================
import * as vscode from 'vscode';
import * as ts from 'typescript';
import { StateManager } from '../core/StateManager';

/**
 * Provides real-time manifesto compliance diagnostics using AST-based analysis
 * Implements the Traditional UI part of the Duality Principle for proactive guidance
 */
export class ManifestoDiagnosticsProvider {
    private diagnosticCollection: vscode.DiagnosticCollection;
    private disposables: vscode.Disposable[] = [];

    constructor(private _stateManager: StateManager) {
        this.diagnosticCollection = vscode.languages.createDiagnosticCollection('manifesto-enforcer');
        
        // Watch for document changes
        this.disposables.push(
            vscode.workspace.onDidChangeTextDocument(this.onDocumentChange.bind(this)),
            vscode.workspace.onDidOpenTextDocument(this.analyzeDocument.bind(this)),
            vscode.workspace.onDidSaveTextDocument(this.analyzeDocument.bind(this))
        );

        // Analyze all open documents
        vscode.workspace.textDocuments.forEach(doc => this.analyzeDocument(doc));
    }

    /**
     * Handle document changes with debouncing
     */
    private onDocumentChange(event: vscode.TextDocumentChangeEvent): void {
        // Debounce to avoid excessive analysis
        setTimeout(() => {
            this.analyzeDocument(event.document);
        }, 500);
    }

    /**
     * Analyze a document for manifesto violations using AST parsing
     */
    private analyzeDocument(document: vscode.TextDocument): void {
        if (!this.shouldAnalyzeDocument(document)) {
            return;
        }

        const diagnostics: vscode.Diagnostic[] = [];
        
        try {
            // Parse the source code into an AST
            const sourceFile = ts.createSourceFile(
                document.fileName,
                document.getText(),
                ts.ScriptTarget.Latest,
                true
            );
            
            // Perform AST-based analysis
            this.visitNode(sourceFile, diagnostics, document);
            
        } catch (error) {
            console.error('Error analyzing document with AST:', error);
            // Fallback to clearing diagnostics if AST parsing fails
        }

        // Set diagnostics for this document
        this.diagnosticCollection.set(document.uri, diagnostics);
    }

    /**
     * Visit AST nodes recursively to find violations
     */
    private visitNode(node: ts.Node, diagnostics: vscode.Diagnostic[], document: vscode.TextDocument): void {
        // Check for innerHTML usage (XSS vulnerability)
        if (ts.isPropertyAccessExpression(node) && node.name.text === 'innerHTML') {
            const start = document.positionAt(node.getStart());
            const end = document.positionAt(node.getEnd());
            
            diagnostics.push(this.createDiagnostic(
                new vscode.Range(start, end),
                'Manifesto Violation: innerHTML usage detected (XSS vulnerability)',
                'Use textContent, createElement, or safe DOM methods instead',
                vscode.DiagnosticSeverity.Error
            ));
        }

        // Check for eval() usage (code injection risk)
        if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && node.expression.text === 'eval') {
            const start = document.positionAt(node.expression.getStart());
            const end = document.positionAt(node.expression.getEnd());
            
            diagnostics.push(this.createDiagnostic(
                new vscode.Range(start, end),
                'Manifesto Violation: eval() usage detected (code injection risk)',
                'Avoid eval() - use safer alternatives like JSON.parse() or proper function calls',
                vscode.DiagnosticSeverity.Error
            ));
        }

        // Check for console.log usage (production code cleanup)
        if (ts.isCallExpression(node) && 
            ts.isPropertyAccessExpression(node.expression) &&
            ts.isIdentifier(node.expression.expression) &&
            node.expression.expression.text === 'console' &&
            node.expression.name.text === 'log' &&
            !document.fileName.includes('test') && 
            !document.fileName.includes('spec')) {
            
            const start = document.positionAt(node.expression.getStart());
            const end = document.positionAt(node.expression.getEnd());
            
            diagnostics.push(this.createDiagnostic(
                new vscode.Range(start, end),
                'Manifesto Violation: console.log in production code',
                'Remove console.log statements before production deployment',
                vscode.DiagnosticSeverity.Warning
            ));
        }

        // Check for hardcoded credentials
        if (ts.isPropertyAssignment(node) && ts.isStringLiteral(node.initializer)) {
            const propertyName = ts.isIdentifier(node.name) ? node.name.text : 
                               ts.isStringLiteral(node.name) ? node.name.text : '';
            
            if (this.isCredentialProperty(propertyName)) {
                const start = document.positionAt(node.getStart());
                const end = document.positionAt(node.getEnd());
                
                diagnostics.push(this.createDiagnostic(
                    new vscode.Range(start, end),
                    'Manifesto Violation: Potential hardcoded credential',
                    'Use environment variables or secure configuration for credentials',
                    vscode.DiagnosticSeverity.Error
                ));
            }
        }

        // Check for hardcoded credentials in variable declarations
        if (ts.isVariableDeclaration(node) && 
            ts.isIdentifier(node.name) && 
            node.initializer && 
            ts.isStringLiteral(node.initializer)) {
            
            if (this.isCredentialProperty(node.name.text)) {
                const start = document.positionAt(node.getStart());
                const end = document.positionAt(node.getEnd());
                
                diagnostics.push(this.createDiagnostic(
                    new vscode.Range(start, end),
                    'Manifesto Violation: Potential hardcoded credential',
                    'Use environment variables or secure configuration for credentials',
                    vscode.DiagnosticSeverity.Error
                ));
            }
        }

        // Check for missing JSDoc on exported functions
        if (this.isExportedFunction(node) && !this.hasJSDocComment(node)) {
            const start = document.positionAt(node.getStart());
            const nameEnd = this.getFunctionNameEnd(node, document);
            
            diagnostics.push(this.createDiagnostic(
                new vscode.Range(start, nameEnd),
                'Manifesto Violation: Missing JSDoc documentation',
                'Add JSDoc comments to document public functions',
                vscode.DiagnosticSeverity.Information
            ));
        }

        // Check for async functions without error handling
        if (this.isAsyncFunction(node) && !this.hasTryCatchBlock(node)) {
            const start = document.positionAt(node.getStart());
            const asyncEnd = this.getAsyncKeywordEnd(node, document);
            
            diagnostics.push(this.createDiagnostic(
                new vscode.Range(start, asyncEnd),
                'Manifesto Violation: Async function without error handling',
                'Add try-catch blocks to handle potential errors',
                vscode.DiagnosticSeverity.Warning
            ));
        }

        // Check for function length
        if ((ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) && node.body) {
            const statementCount = node.body.statements.length;
            if (statementCount > 50) {
                const start = document.positionAt(node.getStart());
                const nameEnd = this.getFunctionNameEnd(node, document);
                
                diagnostics.push(this.createDiagnostic(
                    new vscode.Range(start, nameEnd),
                    'Manifesto Violation: Function too long',
                    `Function has ${statementCount} statements (limit: 50). Consider breaking into smaller functions`,
                    vscode.DiagnosticSeverity.Information
                ));
            }
        }

        // Continue visiting child nodes
        ts.forEachChild(node, child => this.visitNode(child, diagnostics, document));
    }

    /**
     * Check if a property name indicates a credential
     */
    private isCredentialProperty(name: string): boolean {
        const lowerName = name.toLowerCase();
        return lowerName.includes('password') || 
               lowerName.includes('apikey') || 
               lowerName.includes('api_key') || 
               lowerName.includes('secret') || 
               lowerName.includes('token');
    }

    /**
     * Check if a node is an exported function
     */
    private isExportedFunction(node: ts.Node): boolean {
        const isFunctionWithExport = ts.isFunctionDeclaration(node) && this.hasExportModifier(node);
        const isPublicMethod = ts.isMethodDeclaration(node) && this.isPublicMethod(node);
        const isExportedArrowFunction = ts.isVariableDeclaration(node) && 
                                       node.parent && node.parent.parent && 
                                       this.hasExportModifier(node.parent.parent as ts.Node) && 
                                       node.initializer && 
                                       ts.isArrowFunction(node.initializer);
        
        return Boolean(isFunctionWithExport || isPublicMethod || isExportedArrowFunction);
    }

    /**
     * Check if a node has export modifier
     */
    private hasExportModifier(node: ts.Node): boolean {
        if (!node) return false;
        const modifiersNode = node as any;
        if (!modifiersNode.modifiers) return false;
        const result = modifiersNode.modifiers.some((modifier: ts.Modifier) => modifier.kind === ts.SyntaxKind.ExportKeyword);
        return Boolean(result);
    }

    /**
     * Check if a method is public
     */
    private isPublicMethod(node: ts.MethodDeclaration): boolean {
        if (!node.modifiers) return true; // Default is public
        return !node.modifiers.some((modifier: any) => 
            modifier.kind === ts.SyntaxKind.PrivateKeyword || 
            modifier.kind === ts.SyntaxKind.ProtectedKeyword
        );
    }

    /**
     * Check if a function has JSDoc comments
     */
    private hasJSDocComment(node: ts.Node): boolean {
        const sourceFile = node.getSourceFile();
        const fullText = sourceFile.getFullText();

        // Look for JSDoc comment before the node
        const leadingTrivia = fullText.substring(node.getFullStart(), node.getStart());
        return leadingTrivia.includes('/**') && leadingTrivia.includes('*/');
    }

    /**
     * Check if a node is an async function
     */
    private isAsyncFunction(node: ts.Node): boolean {
        if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node) || ts.isArrowFunction(node)) {
            if (!node.modifiers) return false;
            return node.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.AsyncKeyword);
        }
        return false;
    }

    /**
     * Check if a function has try-catch blocks
     */
    private hasTryCatchBlock(node: ts.Node): boolean {
        let hasTryCatch = false;
        
        const visit = (child: ts.Node) => {
            if (ts.isTryStatement(child)) {
                hasTryCatch = true;
                return;
            }
            ts.forEachChild(child, visit);
        };
        
        ts.forEachChild(node, visit);
        return hasTryCatch;
    }

    /**
     * Get the end position of function name for precise diagnostics
     */
    private getFunctionNameEnd(node: ts.Node, document: vscode.TextDocument): vscode.Position {
        if (ts.isFunctionDeclaration(node) && node.name) {
            return document.positionAt(node.name.getEnd());
        }
        if (ts.isMethodDeclaration(node)) {
            return document.positionAt(node.name.getEnd());
        }
        if (ts.isVariableDeclaration(node) && ts.isIdentifier(node.name)) {
            return document.positionAt(node.name.getEnd());
        }
        // Fallback
        return document.positionAt(node.getStart() + 20);
    }

    /**
     * Get the end position of async keyword for precise diagnostics
     */
    private getAsyncKeywordEnd(node: ts.Node, document: vscode.TextDocument): vscode.Position {
        const modifiersNode = node as any;
        if (modifiersNode.modifiers) {
            const asyncModifier = modifiersNode.modifiers.find((m: any) => m.kind === ts.SyntaxKind.AsyncKeyword);
            if (asyncModifier) {
                return document.positionAt(asyncModifier.getEnd());
            }
        }
        // Fallback
        return document.positionAt(node.getStart() + 5);
    }

    /**
     * Create a diagnostic object with precise AST-based positioning
     */
    private createDiagnostic(
        range: vscode.Range,
        message: string,
        detail: string,
        severity: vscode.DiagnosticSeverity
    ): vscode.Diagnostic {
        const diagnostic = new vscode.Diagnostic(range, message, severity);
        diagnostic.source = 'Manifesto Enforcer';
        diagnostic.code = 'manifesto-violation';
        
        // Add related information
        diagnostic.relatedInformation = [
            new vscode.DiagnosticRelatedInformation(
                new vscode.Location(vscode.window.activeTextEditor?.document.uri || vscode.Uri.file(''), range),
                detail
            )
        ];

        return diagnostic;
    }

    /**
     * Check if document should be analyzed
     */
    private shouldAnalyzeDocument(document: vscode.TextDocument): boolean {
        // Only analyze code files
        const codeExtensions = ['.ts', '.js', '.tsx', '.jsx'];
        const extension = document.fileName.substring(document.fileName.lastIndexOf('.'));
        return codeExtensions.includes(extension) && document.uri.scheme === 'file';
    }

    /**
     * Get all diagnostics for a document
     */
    getDiagnostics(document: vscode.TextDocument): readonly vscode.Diagnostic[] {
        return this.diagnosticCollection.get(document.uri) || [];
    }

    /**
     * Clear all diagnostics
     */
    clearDiagnostics(): void {
        this.diagnosticCollection.clear();
    }

    /**
     * Dispose of resources
     */
    dispose(): void {
        this.diagnosticCollection.dispose();
        this.disposables.forEach(d => d.dispose());
    }
}

==================== FILE: src/extension.ts ====================
import * as vscode from 'vscode';
import { StateManager } from './core/StateManager';
import { InteractiveDiffProvider } from './view/InteractiveDiffProvider';
import { ManifestoTreeDataProvider } from './view/ManifestoTreeDataProvider';
import { GlossaryTreeDataProvider } from './view/GlossaryTreeDataProvider';
import { ManifestoDiagnosticsProvider } from './diagnostics/ManifestoDiagnosticsProvider';
import { PiggieActionsProvider } from './view/PiggieActionsProvider';
import { SecurityReviewProvider } from './view/SecurityReviewProvider';
import { ManifestoRulesProvider } from './view/ManifestoRulesProvider';
import { ManifestoCodeActionProvider } from './diagnostics/ManifestoCodeActionProvider';
import { ChatCommandManager } from './commands';

/**
 * Extension activation
 */
export function activate(context: vscode.ExtensionContext) {
    console.log('üê∑ Piggie extension is now active!');

    try {
        // Initialize StateManager singleton first
        const stateManager = StateManager.getInstance(context);

        // Index manifesto for token efficiency
        indexManifesto(stateManager);

        // Initialize providers as local constants (StateManager should only manage data, not service instances)
        const diffProvider = new InteractiveDiffProvider(context, stateManager);
        const manifestoTreeProvider = new ManifestoTreeDataProvider(stateManager);
        const glossaryTreeProvider = new GlossaryTreeDataProvider(context, stateManager);
        const piggieActionsProvider = new PiggieActionsProvider();
        const securityReviewProvider = new SecurityReviewProvider();
        const manifestoRulesProvider = new ManifestoRulesProvider(stateManager);
        const diagnosticsProvider = new ManifestoDiagnosticsProvider(stateManager);
        const codeActionProvider = new ManifestoCodeActionProvider(stateManager);

        // Providers are now managed locally in activate function scope

        // Register tree data providers
        context.subscriptions.push(
            vscode.window.registerTreeDataProvider('manifestoView', manifestoTreeProvider),
            vscode.window.registerTreeDataProvider('glossaryView', glossaryTreeProvider),
            vscode.window.registerTreeDataProvider('piggieActions', piggieActionsProvider),
            vscode.window.registerTreeDataProvider('piggieSecurityReview', securityReviewProvider),
            vscode.window.registerTreeDataProvider('manifestoRules', manifestoRulesProvider)
        );

        // Register diagnostic and code action providers
        context.subscriptions.push(
            vscode.languages.registerCodeActionsProvider(
                { scheme: 'file', language: '*' },
                codeActionProvider,
                {
                    providedCodeActionKinds: [vscode.CodeActionKind.QuickFix, vscode.CodeActionKind.SourceFixAll]
                }
            )
        );

        // Initialize diagnostics provider (it manages its own diagnostics collection)
        // The diagnostics provider is automatically activated through its constructor
        // Store reference for proper disposal
        context.subscriptions.push({
            dispose: () => diagnosticsProvider.dispose()
        });

        // Register chat provider with context for persistence
        const provider = new PiggieChatProvider(context.extensionUri, context, stateManager);
        context.subscriptions.push(
            vscode.window.registerWebviewViewProvider('piggieChatPanel', provider)
        );

        // Register all commands
        context.subscriptions.push(
            vscode.commands.registerCommand('manifestoEnforcer.toggleManifestoMode', () => {
                stateManager.isManifestoMode = !stateManager.isManifestoMode;
                vscode.window.showInformationMessage(`üõ°Ô∏è Manifesto Mode: ${stateManager.isManifestoMode ? 'ON' : 'OFF'}`);
            }),

            vscode.commands.registerCommand('manifestoEnforcer.switchAgent', async () => {
                const agents = ['Auggie', 'Amazon Q', 'Cline'];
                const selected = await vscode.window.showQuickPick(agents, {
                    placeHolder: 'Select AI Agent for Piggie'
                });
                if (selected) {
                    stateManager.currentAgent = selected;
                    vscode.window.showInformationMessage(`üê∑ Piggie is now using: ${selected}`);
                }
            }),

            vscode.commands.registerCommand('manifestoEnforcer.quickChat', async () => {
                const input = await vscode.window.showInputBox({
                    placeHolder: 'Ask Piggie anything...',
                    prompt: 'Quick chat with Piggie'
                });
                if (input) {
                    vscode.commands.executeCommand('piggieChatPanel.focus');
                    // Send message to chat panel
                    provider.handleQuickMessage(input);
                }
            }),

            vscode.commands.registerCommand('manifestoEnforcer.writeCode', async () => {
                const input = await vscode.window.showInputBox({
                    placeHolder: 'Describe what code you want Piggie to write...',
                    prompt: 'Piggie: Write Code'
                });
                if (input) {
                    vscode.commands.executeCommand('piggieChatPanel.focus');
                    provider.handleQuickMessage(`Write code: ${input}`);
                }
            }),

            vscode.commands.registerCommand('manifestoEnforcer.openChat', () => {
                vscode.commands.executeCommand('piggieChatPanel.focus');
            }),

            vscode.commands.registerCommand('manifestoEnforcer.validateCompliance', async () => {
                const editor = vscode.window.activeTextEditor;
                if (editor) {
                    const text = editor.document.getText();
                    vscode.commands.executeCommand('piggieChatPanel.focus');
                    provider.handleQuickMessage(`Validate manifesto compliance for this code: ${text.substring(0, 500)}...`);
                } else {
                    vscode.window.showWarningMessage('No active editor to validate');
                }
            }),

            vscode.commands.registerCommand('manifestoEnforcer.createManifesto', async () => {
                const input = await vscode.window.showInputBox({
                    placeHolder: 'Describe your project to create a manifesto...',
                    prompt: 'Create New Manifesto'
                });
                if (input) {
                    vscode.commands.executeCommand('piggieChatPanel.focus');
                    provider.handleQuickMessage(`Create a manifesto for: ${input}`);
                }
            }),

            vscode.commands.registerCommand('manifestoEnforcer.openSettings', () => {
                vscode.commands.executeCommand('workbench.action.openSettings', 'manifestoEnforcer');
            }),

            vscode.commands.registerCommand('manifestoEnforcer.testConnection', async () => {
                try {
                    vscode.window.showInformationMessage('üîß Testing Piggie connection...');
                    // Test the current agent connection
                    const testMessage = 'Hello, this is a connection test.';
                    provider.handleQuickMessage(testMessage);
                    vscode.window.showInformationMessage('‚úÖ Piggie connection test sent');
                } catch (error) {
                    vscode.window.showErrorMessage(`‚ùå Connection test failed: ${error}`);
                }
            }),

            vscode.commands.registerCommand('piggie.discoverAPIs', async () => {
                vscode.commands.executeCommand('piggieChatPanel.focus');
                provider.handleQuickMessage('Discover and analyze available AI agent APIs in this workspace');
            }),

            vscode.commands.registerCommand('manifestoEnforcer.reviewSelectedCode', async () => {
                const editor = vscode.window.activeTextEditor;
                if (editor && editor.selection) {
                    const selectedText = editor.document.getText(editor.selection);
                    if (selectedText) {
                        vscode.commands.executeCommand('piggieChatPanel.focus');
                        provider.handleQuickMessage(`Review this code for security and compliance: ${selectedText}`);
                    } else {
                        vscode.window.showWarningMessage('No code selected');
                    }
                } else {
                    vscode.window.showWarningMessage('No active editor or selection');
                }
            }),

            vscode.commands.registerCommand('manifestoEnforcer.refactorSelectedCode', async () => {
                const editor = vscode.window.activeTextEditor;
                if (editor && editor.selection) {
                    const selectedText = editor.document.getText(editor.selection);
                    if (selectedText) {
                        vscode.commands.executeCommand('piggieChatPanel.focus');
                        provider.handleQuickMessage(`Refactor this code following manifesto guidelines: ${selectedText}`);
                    } else {
                        vscode.window.showWarningMessage('No code selected');
                    }
                } else {
                    vscode.window.showWarningMessage('No active editor or selection');
                }
            }),

            vscode.commands.registerCommand('manifestoEnforcer.explainSelectedCode', async () => {
                const editor = vscode.window.activeTextEditor;
                if (editor && editor.selection) {
                    const selectedText = editor.document.getText(editor.selection);
                    if (selectedText) {
                        vscode.commands.executeCommand('piggieChatPanel.focus');
                        provider.handleQuickMessage(`Explain this code: ${selectedText}`);
                    } else {
                        vscode.window.showWarningMessage('No code selected');
                    }
                } else {
                    vscode.window.showWarningMessage('No active editor or selection');
                }
            }),

            vscode.commands.registerCommand('manifestoEnforcer.sendToAmazonQ', async () => {
                const editor = vscode.window.activeTextEditor;
                if (editor && editor.selection) {
                    const selectedText = editor.document.getText(editor.selection);
                    if (selectedText) {
                        stateManager.currentAgent = 'Amazon Q';
                        vscode.commands.executeCommand('piggieChatPanel.focus');
                        provider.handleQuickMessage(`[Amazon Q Enhanced] ${selectedText}`);
                    } else {
                        vscode.window.showWarningMessage('No code selected');
                    }
                } else {
                    vscode.window.showWarningMessage('No active editor or selection');
                }
            }),

            vscode.commands.registerCommand('manifestoEnforcer.refreshManifesto', () => {
                // Reload manifesto by re-indexing it
                indexManifesto(stateManager);
                vscode.window.showInformationMessage('üìã Manifesto refreshed');
            }),

            vscode.commands.registerCommand('manifestoEnforcer.refreshGlossary', () => {
                stateManager.loadGlossaryFromStorage();
                vscode.window.showInformationMessage('üìñ Glossary refreshed');
            }),

            vscode.commands.registerCommand('manifestoEnforcer.addGlossaryTermFromTree', async () => {
                try {
                    vscode.commands.executeCommand('piggieChatPanel.focus');
                    provider.showGlossaryPanel();
                } catch (error) {
                    vscode.window.showErrorMessage(`Failed to show glossary panel: ${error}`);
                }
            }),

            vscode.commands.registerCommand('manifestoEnforcer.removeGlossaryTerm', async () => {
                try {
                    const terms = Array.from(stateManager.projectGlossary.keys());
                    if (terms.length === 0) {
                        vscode.window.showInformationMessage('No glossary terms to remove');
                        return;
                    }
                    const selected = await vscode.window.showQuickPick(terms, {
                        placeHolder: 'Select term to remove'
                    });
                    if (selected) {
                        stateManager.projectGlossary.delete(selected);
                        await stateManager.saveGlossaryToStorage();
                        vscode.window.showInformationMessage(`Removed term: ${selected}`);
                    }
                } catch (error) {
                    vscode.window.showErrorMessage(`Failed to remove term: ${error}`);
                }
            })
        );

        // Load saved codebase index on startup
        stateManager.loadCodebaseIndex().then((loaded: boolean) => {
            if (loaded) {
                stateManager.isCodebaseIndexed = true;
            }
        });

        // Load saved glossary on startup
        stateManager.loadGlossaryFromStorage().then(() => {
            // Loaded message is already logged in StateManager
        });

        // Setup file change detection for auto re-indexing
        setupFileChangeDetection(stateManager);

        console.log('üê∑ Piggie extension activated successfully');

    } catch (error) {
        console.error('üê∑ Extension activation failed:', error);
        vscode.window.showErrorMessage('Failed to activate Manifesto Enforcer: ' + error);
    }
}

/**
 * Extension deactivation
 */
export function deactivate() {
    console.log('üê∑ Piggie extension is now deactivated');
}

/**
 * Index manifesto rules for efficient token usage
 */
function indexManifesto(stateManager: StateManager): void {
    try {
        // Basic manifesto rules - can be expanded
        const manifestoRules = [
            {
                id: 'error-handling',
                title: 'Comprehensive Error Handling',
                description: 'All functions must include proper error handling with try-catch blocks',
                category: 'reliability'
            },
            {
                id: 'input-validation',
                title: 'Input Validation',
                description: 'All inputs must be validated before processing',
                category: 'security'
            },
            {
                id: 'documentation',
                title: 'Code Documentation',
                description: 'All public functions and classes must be documented',
                category: 'maintainability'
            }
        ];

        stateManager.manifestoRules = manifestoRules;
        console.log('üìã Manifesto rules indexed successfully');
    } catch (error) {
        console.error('Failed to index manifesto:', error);
    }
}



/**
 * Setup file change detection for auto re-indexing
 */
function setupFileChangeDetection(stateManager: StateManager): void {
    try {
        const watcher = vscode.workspace.createFileSystemWatcher('**/*.{ts,js,tsx,jsx,py,java,cs,cpp,h}');
        
        watcher.onDidChange(() => {
            if (stateManager.isCodebaseIndexed) {
                console.log('üîÑ File changed, marking index as stale');
                // Could trigger re-indexing here if desired
            }
        });

        watcher.onDidCreate(() => {
            if (stateManager.isCodebaseIndexed) {
                console.log('üìÑ New file created, marking index as stale');
            }
        });

        watcher.onDidDelete(() => {
            if (stateManager.isCodebaseIndexed) {
                console.log('üóëÔ∏è File deleted, marking index as stale');
            }
        });
    } catch (error) {
        console.error('Failed to setup file change detection:', error);
    }
}



// The old generateManifestoCompliantResponse function has been replaced by the ChatCommandManager
// All command logic is now handled by individual command classes in the src/commands/ directory

// Q-optimized response generation is now handled by individual commands
// Each command can implement its own optimization logic as needed





/**
 * Simple chat provider for the codebase indexing system
 * Now uses the Command Pattern via ChatCommandManager
 */
class PiggieChatProvider implements vscode.WebviewViewProvider {
    public static readonly viewType = 'piggieChatPanel';
    private _view?: vscode.WebviewView;
    private stateManager: StateManager;
    private commandManager: ChatCommandManager;

    constructor(private readonly _extensionUri: vscode.Uri, context?: vscode.ExtensionContext, stateManager?: StateManager) {
        this.stateManager = stateManager || StateManager.getInstance(context);
        this.commandManager = new ChatCommandManager();
    }

    public resolveWebviewView(
        webviewView: vscode.WebviewView,
        _context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken,
    ) {
        this._view = webviewView;

        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [this._extensionUri]
        };

        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

        // Handle messages from webview
        webviewView.webview.onDidReceiveMessage(async (data) => {
            try {
                switch (data.command) {
                    case 'sendMessage':
                        await this.handleUserMessage(data.text);
                        break;
                    case 'indexCodebase':
                        // This is now handled through the StateManager for consistency
                        await this.stateManager.startIndexing();
                        this.updateIndexStatus(); // Notify UI of completion
                        break;
                    case 'changeSetting':
                        // Handle specific setting changes with proper validation
                        switch (data.key) {
                            case 'isManifestoMode':
                                this.stateManager.isManifestoMode = data.value;
                                console.log(`üõ°Ô∏è Manifesto Mode: ${data.value ? 'ON' : 'OFF'}`);
                                break;
                            case 'isAgentMode':
                                this.stateManager.isAgentMode = data.value;
                                console.log(`ü§ñ Agent Mode: ${data.value ? 'ON' : 'OFF'}`);
                                break;
                            case 'currentAgent':
                                this.stateManager.currentAgent = data.value;
                                console.log(`üê∑ Piggie using: ${data.value}`);
                                break;
                            case 'isAutoMode':
                                this.stateManager.isAutoMode = data.value;
                                console.log(`‚ö° Auto Mode: ${data.value ? 'ON' : 'OFF'}`);
                                break;
                            default:
                                console.warn(`Unknown setting: ${data.key}`);
                        }
                        break;
                }
            } catch (error) {
                this.sendResponse('‚ùå Error: ' + (error instanceof Error ? error.message : String(error)));
            }
        });

        // Initialize status
        this.updateIndexStatus();
    }

    private async handleCodebaseIndexing(): Promise<void> {
        try {
            this.sendResponse('üìö Starting codebase indexing...');

            const result = await this.stateManager.startIndexing();
            this.sendResponse(result.message);
            this.updateIndexStatus();

        } catch (error) {
            console.error('Indexing failed:', error);
            this.sendResponse('‚ùå Failed to index codebase: ' + (error instanceof Error ? error.message : String(error)));
            this.updateIndexStatus();
        }
    }

    private async handleUserMessage(message: string): Promise<void> {
        try {
            // Use the ChatCommandManager instead of the old if/else if block
            const response = await this.commandManager.handleMessage(message, this.stateManager);
            this.sendResponse(response);
        } catch (error) {
            this.sendResponse('üê∑ Error: ' + error);
        }
    }

    private sendResponse(content: string): void {
        if (this._view) {
            this._view.webview.postMessage({
                command: 'addMessage',
                content: content
            });
        }
    }

    public handleQuickMessage(message: string): void {
        // Add the user message to the chat
        if (this._view) {
            this._view.webview.postMessage({
                command: 'addMessage',
                role: 'user',
                content: message
            });
        }
        // Process the message through the normal flow
        this.handleUserMessage(message);
    }

    public showGlossaryPanel(): void {
        if (this._view) {
            this._view.webview.postMessage({
                command: 'showGlossaryPanel'
            });
        }
    }

    private updateIndexStatus(): void {
        if (this._view) {
            this._view.webview.postMessage({
                command: 'updateIndexStatus',
                isIndexed: this.stateManager.isCodebaseIndexed,
                fileCount: this.stateManager.codebaseIndex.size
            });
        }
    }

    private _getHtmlForWebview(_webview: vscode.Webview): string {
        // This is the original V1 UI, which will be adapted to the V2 architecture.
        return `<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Piggie Chat</title>
            <style>
                body { font-family: var(--vscode-font-family); font-size: var(--vscode-font-size); color: var(--vscode-foreground); background: var(--vscode-editor-background); margin: 0; padding: 0; overflow: hidden; }
                .chat-container { display: flex; flex-direction: column; height: 100vh; }

                /* Top toolbar */
                .top-toolbar { display: flex; align-items: center; gap: 12px; padding: 8px 12px; background: var(--vscode-sideBar-background); border-bottom: 1px solid var(--vscode-sideBar-border); }
                .toolbar-button { padding: 6px 12px; background: var(--vscode-button-background); color: var(--vscode-button-foreground); border: none; border-radius: 3px; cursor: pointer; font-size: 12px; }
                .toolbar-button:hover { background: var(--vscode-button-hoverBackground); }
                .status-indicator { font-size: 11px; color: var(--vscode-descriptionForeground); }

                /* Messages area */
                .messages { flex: 1; overflow-y: auto; padding: 12px; min-height: 0; }
                .message { padding: 10px 12px; border-radius: 6px; margin: 8px 0; word-wrap: break-word; line-height: 1.4; }
                .user-message { background: var(--vscode-inputValidation-infoBackground); border-left: 3px solid var(--vscode-inputValidation-infoBorder); margin-left: 20px; }
                .ai-message { background: var(--vscode-textBlockQuote-background); border-left: 3px solid var(--vscode-charts-blue); }

                /* Message content formatting */
                .message strong { font-weight: bold; color: var(--vscode-foreground); }
                .message ul { margin: 8px 0; padding-left: 20px; }
                .message li { margin: 2px 0; }
                .message pre { background: var(--vscode-textCodeBlock-background); border: 1px solid var(--vscode-input-border); border-radius: 4px; padding: 12px; margin: 8px 0; overflow-x: auto; }
                .message code { background: var(--vscode-textCodeBlock-background); border: 1px solid var(--vscode-input-border); border-radius: 3px; padding: 2px 4px; font-family: var(--vscode-editor-font-family); font-size: 0.9em; }
                .message pre code { background: none; border: none; padding: 0; }

                /* Message content formatting */
                .message strong { font-weight: bold; color: var(--vscode-foreground); }
                .message ul { margin: 8px 0; padding-left: 20px; }
                .message li { margin: 2px 0; }
                .message pre { background: var(--vscode-textCodeBlock-background); border: 1px solid var(--vscode-input-border); border-radius: 4px; padding: 12px; margin: 8px 0; overflow-x: auto; }
                .message code { background: var(--vscode-textCodeBlock-background); border: 1px solid var(--vscode-input-border); border-radius: 3px; padding: 2px 4px; font-family: var(--vscode-editor-font-family); font-size: 0.9em; }
                .message pre code { background: none; border: none; padding: 0; }
                /* Input section */
                .input-section { flex-shrink: 0; padding: 12px; background: var(--vscode-sideBar-background); border-top: 1px solid var(--vscode-sideBar-border); }
                .mode-controls { display: flex; gap: 8px; margin-bottom: 8px; align-items: center; }
                .mode-select { background: var(--vscode-dropdown-background); color: var(--vscode-dropdown-foreground); border: 1px solid var(--vscode-dropdown-border); border-radius: 3px; padding: 4px 8px; font-size: 11px; min-width: 100px; }
                .auto-toggle { display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 11px; color: var(--vscode-foreground); user-select: none; }
                .auto-toggle input[type="checkbox"] { margin: 0; }
                .input-container { display: flex; gap: 8px; align-items: stretch; }
                .textarea-container { flex: 1; position: relative; display: flex; flex-direction: column; min-width: 0; }
                .resize-handle { height: 12px; background: var(--vscode-input-background); border: 1px solid var(--vscode-input-border); border-bottom: none; border-radius: 3px 3px 0 0; cursor: ns-resize; display: flex; align-items: center; justify-content: center; font-size: 10px; color: var(--vscode-descriptionForeground); user-select: none; opacity: 0.7; }
                .message-input { width: 100%; padding: 8px 12px; background: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-top: none; border-radius: 0 0 3px 3px; resize: none; min-height: 36px; max-height: 120px; font-family: inherit; font-size: inherit; box-sizing: border-box; }
                .send-button { padding: 8px 16px; background: var(--vscode-button-background); color: var(--vscode-button-foreground); border: none; border-radius: 3px; cursor: pointer; font-size: 12px; align-self: flex-end; white-space: nowrap; flex-shrink: 0; }
                .send-button:hover { background: var(--vscode-button-hoverBackground); }

                /* Hidden glossary panel */
                .glossary-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--vscode-editor-background); border: 1px solid var(--vscode-widget-border); border-radius: 6px; padding: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; min-width: 300px; }
                .glossary-header { font-weight: bold; margin-bottom: 12px; color: var(--vscode-foreground); }
                .glossary-input { display: flex; gap: 8px; align-items: center; }
                .glossary-input input { flex: 1; padding: 6px 8px; background: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px; font-size: 12px; }
                .glossary-add-btn { padding: 6px 12px; background: var(--vscode-button-background); color: var(--vscode-button-foreground); border: none; border-radius: 3px; cursor: pointer; font-size: 12px; }
                .glossary-close-btn { padding: 6px 8px; background: var(--vscode-button-secondaryBackground); color: var(--vscode-button-secondaryForeground); border: none; border-radius: 3px; cursor: pointer; font-size: 12px; }
            </style>
        </head>
        <body>
            <div class="chat-container">
                <!-- Top toolbar - clean and minimal -->
                <div class="top-toolbar">
                    <button id="indexButton" class="toolbar-button">üìö Index Codebase</button>
                    <span id="indexStatus" class="status-indicator">Not indexed</span>
                </div>

                <!-- Messages area -->
                <div id="messages" class="messages">
                    <div class="message ai-message">üê∑ Hi, I'm Piggie! Your Security and Compliance Enforcement Agent. I piggyback on top of your AI development agents, making your code more reliable and secure. Oink Oink!</div>
                </div>

                <!-- Hidden glossary panel (accessed via commands) -->
                <div id="glossaryPanel" class="glossary-panel" style="display: none;">
                    <div class="glossary-header">üìñ Add Glossary Term</div>
                    <div class="glossary-input">
                        <input type="text" id="termInput" placeholder="Term/Acronym"/>
                        <input type="text" id="definitionInput" placeholder="Definition"/>
                        <button id="addTermButton" class="glossary-add-btn">Add</button>
                        <button id="closeGlossaryBtn" class="glossary-close-btn">‚úï</button>
                    </div>
                </div>

                <!-- Input section with controls -->
                <div class="input-section">
                    <!-- Mode controls above input -->
                    <div class="mode-controls">
                        <select id="manifestoDropdown" class="mode-select">
                            <option value="manifesto">üõ°Ô∏è Manifesto Mode</option>
                            <option value="free">üîì Free Mode</option>
                        </select>
                        <select id="modeDropdown" class="mode-select">
                            <option value="chat">üí¨ Chat</option>
                            <option value="agent">ü§ñ Agent</option>
                        </select>
                        <select id="agentDropdown" class="mode-select">
                            <option value="auggie">ü§ñ Auggie</option>
                            <option value="amazonq">üü† Amazon Q</option>
                            <option value="cline">üîµ Cline</option>
                        </select>
                        <label class="auto-toggle">
                            <input type="checkbox" id="autoToggle" />
                            ‚ö° Auto
                        </label>
                    </div>

                    <!-- Text input area -->
                    <div class="input-container">
                        <div class="textarea-container">
                            <div class="resize-handle" id="resizeHandle">‚ãØ</div>
                            <textarea id="messageInput" class="message-input" placeholder="Ask Piggie anything..." rows="1"></textarea>
                        </div>
                        <button id="sendButton" class="send-button">Send</button>
                    </div>
                </div>
            </div>
            <script>
                const vscode = acquireVsCodeApi();

                // DOM Elements
                const messageInput = document.getElementById('messageInput');
                const sendButton = document.getElementById('sendButton');
                const messagesDiv = document.getElementById('messages');
                const indexButton = document.getElementById('indexButton');
                const indexStatus = document.getElementById('indexStatus');
                const manifestoDropdown = document.getElementById('manifestoDropdown');
                const modeDropdown = document.getElementById('modeDropdown');
                const agentDropdown = document.getElementById('agentDropdown');
                const autoToggle = document.getElementById('autoToggle');
                const glossaryPanel = document.getElementById('glossaryPanel');
                const addTermButton = document.getElementById('addTermButton');
                const closeGlossaryBtn = document.getElementById('closeGlossaryBtn');
                const resizeHandle = document.getElementById('resizeHandle');

                // Event Listeners
                sendButton.addEventListener('click', sendMessage);
                messageInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });

                indexButton.addEventListener('click', () => {
                    vscode.postMessage({ command: 'indexCodebase' });
                });

                manifestoDropdown.addEventListener('change', e => {
                    vscode.postMessage({ command: 'changeSetting', key: 'isManifestoMode', value: e.target.value === 'manifesto' });
                });
                modeDropdown.addEventListener('change', e => {
                    vscode.postMessage({ command: 'changeSetting', key: 'isAgentMode', value: e.target.value === 'agent' });
                });
                agentDropdown.addEventListener('change', e => {
                    vscode.postMessage({ command: 'changeSetting', key: 'currentAgent', value: e.target.value });
                });

                autoToggle.addEventListener('change', e => {
                    vscode.postMessage({ command: 'changeSetting', key: 'isAutoMode', value: e.target.checked });
                });

                // Glossary panel controls
                addTermButton.addEventListener('click', () => {
                    const term = document.getElementById('termInput').value.trim();
                    const definition = document.getElementById('definitionInput').value.trim();
                    if (term && definition) {
                        // Use a natural language command that the GlossaryCommand can handle
                        sendMessage(\`Define \${term} as \${definition}\`);
                        document.getElementById('termInput').value = '';
                        document.getElementById('definitionInput').value = '';
                        glossaryPanel.style.display = 'none';
                    }
                });

                closeGlossaryBtn.addEventListener('click', () => {
                    glossaryPanel.style.display = 'none';
                });

                // Resize handle functionality
                let isResizing = false;
                let startY = 0;
                let startHeight = 0;

                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startY = e.clientY;
                    startHeight = messageInput.offsetHeight;
                    document.addEventListener('mousemove', handleResize);
                    document.addEventListener('mouseup', stopResize);
                    e.preventDefault();
                });

                function handleResize(e) {
                    if (!isResizing) return;
                    const deltaY = startY - e.clientY;
                    const newHeight = Math.max(36, Math.min(120, startHeight + deltaY));
                    messageInput.style.height = newHeight + 'px';
                }

                function stopResize() {
                    isResizing = false;
                    document.removeEventListener('mousemove', handleResize);
                    document.removeEventListener('mouseup', stopResize);
                }

                function sendMessage(textOverride) {
                    const text = textOverride || messageInput.value.trim();
                    if (text) {
                        addMessage('user-message', 'üë§ You: ' + text);
                        vscode.postMessage({ command: 'sendMessage', text: text });
                        if (!textOverride) {
                            messageInput.value = '';
                        }
                    }
                }

                function addMessage(className, content) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message ' + className;

                    // Format the content properly
                    const formattedContent = formatMessageContent(content);
                    messageDiv.innerHTML = formattedContent;

                    messagesDiv.appendChild(messageDiv);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                }

                function formatMessageContent(content) {
                    // Basic markdown-like formatting for better readability
                    let formatted = content
                        // Convert **bold** to <strong>
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        // Convert bullet points to proper list items
                        .replace(/^‚Ä¢ (.*$)/gm, '<li>$1</li>')
                        // Convert code blocks
                        .replace(/\`\`\`(\w+)?\n([\s\S]*?)\`\`\`/g, '<pre><code class="language-$1">$2</code></pre>')
                        // Convert inline code
                        .replace(/\`([^\`]+)\`/g, '<code>$1</code>')
                        // Convert line breaks to <br>
                        .replace(/\n/g, '<br>');

                    // Wrap consecutive list items in <ul>
                    formatted = formatted.replace(/(<li>.*<\/li>)(<br>)*(<li>.*<\/li>)/g, '<ul>$1$3</ul>');
                    formatted = formatted.replace(/(<li>.*<\/li>)(<br>)*(<li>.*<\/li>)(<br>)*(<li>.*<\/li>)/g, '<ul>$1$3$5</ul>');
                    formatted = formatted.replace(/(<li>.*<\/li>)(<br>)*(<li>.*<\/li>)(<br>)*(<li>.*<\/li>)(<br>)*(<li>.*<\/li>)/g, '<ul>$1$3$5$7</ul>');

                    return formatted;
                }

                window.addEventListener('message', event => {
                    const message = event.data;
                    switch (message.command) {
                        case 'addMessage':
                            const prefix = message.role === 'error' ? '‚ùå Error: ' : 'üê∑ Piggie: ';
                            addMessage(message.role === 'error' ? 'error' : 'ai-message', prefix + message.content);
                            break;
                        case 'syncState':
                            updateUI(message.state);
                            break;
                        case 'showGlossaryPanel':
                            glossaryPanel.style.display = 'block';
                            document.getElementById('termInput').focus();
                            break;
                    }
                });

                function updateUI(state) {
                    // Update Index Status
                    if (state.codebase.isIndexed) {
                        indexStatus.textContent = \`Indexed (\${state.codebase.fileCount} files)\`;
                        indexButton.textContent = "üîÑ Re-index";
                    } else {
                        indexStatus.textContent = "Not Indexed";
                        indexButton.textContent = "üìö Index Codebase";
                    }

                    // Update Mode Dropdowns and Toggles
                    manifestoDropdown.value = state.core.isManifestoMode ? 'manifesto' : 'free';
                    modeDropdown.value = state.core.isAgentMode ? 'agent' : 'chat';
                    agentDropdown.value = state.core.currentAgent.toLowerCase();
                    autoToggle.checked = state.core.isAutoMode;
                }

                // Function to show glossary panel (called from commands)
                window.showGlossaryPanel = function() {
                    glossaryPanel.style.display = 'block';
                    document.getElementById('termInput').focus();
                };
            </script>
        </body>
        </html>`;
    }
}

==================== FILE: src/file-operations/PiggieFileManager.ts ====================
/**
 * Piggie File Manager - Direct code writing and project analysis
 * Following manifesto: MANDATORY error handling, CRITICAL security, OPTIMIZE performance
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { 
  FileOperation, 
  FileOperationResult, 
  ProjectStructure, 
  CodeQualityResult,
  PerformanceMetrics 
} from '../core/types';

/**
 * File manager for Piggie to write code directly to files
 * Implements all security and performance requirements from manifesto
 */
export class PiggieFileManager {
  private operationCount = 0;
  private performanceMetrics: PerformanceMetrics[] = [];
  private isDisposed = false;

  /**
   * Write code directly to file with manifesto compliance
   * CRITICAL: Input validation, security checks, comprehensive error handling
   */
  async writeCodeToFile(operation: FileOperation): Promise<FileOperationResult> {
    const startTime = Date.now();

    try {
      // CRITICAL: Input validation on all user-facing functions
      this.validateFileOperation(operation);

      // CRITICAL: Security - prevent path traversal attacks
      this.validateFilePath(operation.path);

      // CRITICAL: Sanitize content for security
      const sanitizedContent = this.sanitizeContent(operation.content || '');

      let backupPath: string | undefined;

      // Create backup if requested and file exists
      if (operation.backup && operation.type === 'update') {
        backupPath = await this.createBackup(operation.path);
      }

      // Perform the file operation
      await this.performFileOperation(operation, sanitizedContent);

      // Record performance metrics
      const duration = Date.now() - startTime;
      const metrics = this.recordPerformance('writeCodeToFile', duration);

      // OPTIMIZE: Warn if operation exceeds performance target
      if (duration > 200) {
        console.warn(`File operation took ${duration}ms - exceeds 200ms target`);
      }

      return {
        success: true,
        path: operation.path,
        backupPath,
        performanceMetrics: metrics
      };

    } catch (error) {
      // MANDATORY: Comprehensive error handling with helpful messages
      const errorMessage = error instanceof Error ? error.message : 'Unknown file operation error';
      
      return {
        success: false,
        path: operation.path,
        error: `Failed to write code to file: ${errorMessage}`,
        performanceMetrics: this.recordPerformance('writeCodeToFile', Date.now() - startTime)
      };
    }
  }

  /**
   * Read project structure for context
   * HANDLE: All external operations must have timeout and retry logic
   */
  async readProjectStructure(directoryPath: string): Promise<ProjectStructure> {
    try {
      // CRITICAL: Input validation
      if (!directoryPath || typeof directoryPath !== 'string') {
        return {
          directories: [],
          files: [],
          error: 'Invalid directory path: must be non-empty string'
        };
      }

      // CRITICAL: Security - validate path
      this.validateFilePath(directoryPath);

      const entries = await fs.readdir(directoryPath, { withFileTypes: true });
      
      const directories: string[] = [];
      const files: string[] = [];

      for (const entry of entries) {
        if (entry.isDirectory()) {
          directories.push(entry.name);
        } else if (entry.isFile()) {
          files.push(entry.name);
        }
      }

      return {
        directories,
        files,
        totalSize: entries.length
      };

    } catch (error) {
      // HANDLE: All errors must be logged with appropriate context
      const errorMessage = error instanceof Error ? error.message : 'Unknown directory read error';
      console.error(`Failed to read project structure: ${errorMessage}`);

      return {
        directories: [],
        files: [],
        error: errorMessage
      };
    }
  }

  /**
   * Validate code quality against manifesto rules
   * REQUIRED: Comprehensive validation with detailed feedback
   */
  async validateCodeQuality(code: string): Promise<CodeQualityResult> {
    const startTime = Date.now();

    try {
      // CRITICAL: Input validation
      if (!code || typeof code !== 'string') {
        throw new Error('Invalid code content: must be non-empty string');
      }

      const violations: string[] = [];
      const suggestions: string[] = [];
      let score = 100;

      // Check manifesto requirements
      await this.checkManifestoCompliance(code, violations, suggestions);

      // Calculate score based on violations
      score = Math.max(0, 100 - (violations.length * 10));

      const duration = Date.now() - startTime;
      const metrics = this.recordPerformance('validateCodeQuality', duration);

      return {
        isValid: violations.length === 0,
        score,
        violations,
        suggestions,
        performanceMetrics: metrics
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown validation error';
      throw new Error(`Code quality validation failed: ${errorMessage}`);
    }
  }

  /**
   * Dispose resources
   * MANDATORY: Proper resource disposal
   */
  dispose(): void {
    try {
      this.isDisposed = true;
      this.performanceMetrics = [];
      console.log('PiggieFileManager disposed successfully');
    } catch (error) {
      console.error('Error disposing PiggieFileManager:', error);
    }
  }

  // Private helper methods

  /**
   * Validate file operation input
   * CRITICAL: Input validation on all user-facing functions
   */
  private validateFileOperation(operation: FileOperation): void {
    if (!operation) {
      throw new Error('Invalid file operation: operation cannot be null');
    }

    if (!operation.type || !['create', 'update', 'delete', 'read'].includes(operation.type)) {
      throw new Error('Invalid file operation: invalid operation type');
    }

    if (!operation.path || typeof operation.path !== 'string') {
      throw new Error('Invalid file operation: path must be non-empty string');
    }

    if ((operation.type === 'create' || operation.type === 'update') && 
        typeof operation.content !== 'string') {
      throw new Error('Invalid file operation: content required for create/update operations');
    }
  }

  /**
   * Validate file path for security
   * CRITICAL: Prevent path traversal attacks
   */
  private validateFilePath(filePath: string): void {
    // Check for path traversal attempts
    if (filePath.includes('..') || filePath.includes('~')) {
      throw new Error('Invalid file path: path traversal detected');
    }

    // Check for absolute paths to system directories
    const dangerousPaths = ['/etc', '/usr', '/bin', '/sys', '/proc', 'C:\\Windows', 'C:\\System32'];
    if (dangerousPaths.some(dangerous => filePath.startsWith(dangerous))) {
      throw new Error('Invalid file path: access to system directories denied');
    }

    // Normalize path to prevent bypass attempts
    const normalizedPath = path.normalize(filePath);
    if (normalizedPath !== filePath && normalizedPath.includes('..')) {
      throw new Error('Invalid file path: normalized path contains traversal');
    }
  }

  /**
   * Sanitize file content for security
   * CRITICAL: XSS prevention in all output rendering
   */
  private sanitizeContent(content: string): string {
    if (!content) return '';

    // Remove potentially dangerous content while preserving code structure
    return content
      .replace(/<script[^>]*>.*?<\/script>/gi, '') // Remove script tags
      .replace(/javascript:/gi, '') // Remove javascript: protocols
      .replace(/on\w+\s*=/gi, '') // Remove event handlers
      .trim();
  }

  /**
   * Create backup of existing file
   * HANDLE: All operations must have comprehensive error handling
   */
  private async createBackup(filePath: string): Promise<string> {
    try {
      // Check if file exists
      await fs.access(filePath);
      
      // Read existing content
      const existingContent = await fs.readFile(filePath, 'utf8');
      
      // Create backup with timestamp
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = `${filePath}.backup.${timestamp}`;
      
      await fs.writeFile(backupPath, existingContent, 'utf8');
      
      return backupPath;

    } catch (error) {
      // If file doesn't exist, no backup needed
      if ((error as any).code === 'ENOENT') {
        return '';
      }
      throw error;
    }
  }

  /**
   * Perform the actual file operation
   */
  private async performFileOperation(operation: FileOperation, content: string): Promise<void> {
    switch (operation.type) {
      case 'create':
      case 'update':
        // CRITICAL: Type-safe encoding handling
        const encoding = (operation.encoding as BufferEncoding) || 'utf8';
        await fs.writeFile(operation.path, content, encoding);
        break;
      case 'delete':
        await fs.unlink(operation.path);
        break;
      case 'read':
        // Read operation doesn't modify files
        break;
      default:
        throw new Error(`Unsupported operation type: ${operation.type}`);
    }
  }

  /**
   * Check code against manifesto compliance rules
   * REQUIRED: Comprehensive validation
   */
  private async checkManifestoCompliance(
    code: string, 
    violations: string[], 
    suggestions: string[]
  ): Promise<void> {
    // Check for JSDoc documentation (MANDATORY)
    if (!code.includes('/**') || !code.includes('*/')) {
      violations.push('Missing JSDoc documentation');
      suggestions.push('Add JSDoc comments to all public functions');
    }

    // Check for error handling (MANDATORY)
    if (!code.includes('try') && !code.includes('catch') && !code.includes('throw')) {
      violations.push('Missing error handling');
      suggestions.push('Add try-catch blocks for error handling');
    }

    // Check for input validation (CRITICAL)
    if (!code.includes('if') || !code.includes('throw new Error')) {
      violations.push('Missing input validation');
      suggestions.push('Add input validation with proper error messages');
    }

    // Check function length (STYLE: Keep functions under 50 lines)
    const functions = code.match(/function\s+\w+[^{]*{[^}]*}/g) || [];
    for (const func of functions) {
      const lineCount = func.split('\n').length;
      if (lineCount > 50) {
        violations.push(`Function exceeds 50 lines (${lineCount} lines)`);
        suggestions.push('Break large functions into smaller, focused functions');
      }
    }

    // Check for descriptive names (STYLE)
    const badNames = code.match(/\b(a|b|c|x|y|z|temp|data|item)\b/g);
    if (badNames && badNames.length > 0) {
      violations.push('Non-descriptive variable names detected');
      suggestions.push('Use descriptive variable and function names');
    }
  }

  /**
   * Record performance metrics
   * OPTIMIZE: Monitor system performance as per manifesto
   */
  private recordPerformance(operation: string, duration: number): PerformanceMetrics {
    const metrics: PerformanceMetrics = {
      responseTime: duration,
      memoryUsage: process.memoryUsage().heapUsed,
      timestamp: new Date()
    };

    this.performanceMetrics.push(metrics);

    // Keep only last 100 metrics to prevent memory leaks
    if (this.performanceMetrics.length > 100) {
      this.performanceMetrics = this.performanceMetrics.slice(-100);
    }

    return metrics;
  }
}

==================== FILE: src/file-operations/__tests__/PiggieFileManager.test.ts ====================
/**
 * Test suite for PiggieFileManager
 * Following manifesto: REQUIRED unit tests for all business logic, MANDATORY error handling
 */

import { PiggieFileManager } from '../PiggieFileManager';
import { FileOperation } from '../../core/types';
import * as fs from 'fs/promises';

// Mock fs module
jest.mock('fs/promises');
const mockFs = fs as jest.Mocked<typeof fs>;

describe('PiggieFileManager', () => {
  let fileManager: PiggieFileManager;

  beforeEach(() => {
    fileManager = new PiggieFileManager();
    jest.clearAllMocks();
  });

  afterEach(() => {
    fileManager.dispose();
  });

  describe('writeCodeToFile', () => {
    it('should write code to file successfully', async () => {
      const operation: FileOperation = {
        type: 'create',
        path: 'test.ts',
        content: 'console.log("Hello, Piggie!");',
        backup: true
      };

      mockFs.writeFile.mockResolvedValue(undefined);
      mockFs.access.mockRejectedValue(new Error('File not found')); // File doesn't exist

      const result = await fileManager.writeCodeToFile(operation);

      expect(result.success).toBe(true);
      expect(result.path).toBe('test.ts');
      expect(mockFs.writeFile).toHaveBeenCalledWith('test.ts', operation.content, 'utf8');
    });

    it('should create backup before overwriting existing file', async () => {
      const operation: FileOperation = {
        type: 'update',
        path: 'existing.ts',
        content: 'new content',
        backup: true
      };

      mockFs.access.mockResolvedValue(undefined); // File exists
      mockFs.readFile.mockResolvedValue('old content');
      mockFs.writeFile.mockResolvedValue(undefined);

      await fileManager.writeCodeToFile(operation);

      // Verify backup was created
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        expect.stringContaining('existing.ts.backup'),
        'old content',
        'utf8'
      );
    });

    it('should validate file operation input', async () => {
      // CRITICAL: Input validation on all user-facing functions
      const invalidOperation = {
        type: 'invalid' as any,
        path: '',
        content: undefined
      } as any;

      const result = await fileManager.writeCodeToFile(invalidOperation);
      expect(result.success).toBe(false);
      expect(result.error).toContain('Invalid file operation');
    });

    it('should handle file system errors gracefully', async () => {
      const operation: FileOperation = {
        type: 'create',
        path: '/invalid/path/test.ts',
        content: 'test'
      };

      mockFs.writeFile.mockRejectedValue(new Error('Permission denied'));

      const result = await fileManager.writeCodeToFile(operation);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Permission denied');
    });

    it('should complete within performance requirements', async () => {
      const operation: FileOperation = {
        type: 'create',
        path: 'perf-test.ts',
        content: 'test content'
      };

      mockFs.writeFile.mockResolvedValue(undefined);
      mockFs.access.mockRejectedValue(new Error('File not found'));

      const startTime = Date.now();
      await fileManager.writeCodeToFile(operation);
      const duration = Date.now() - startTime;

      expect(duration).toBeLessThan(200); // OPTIMIZE: sub-200ms requirement
    });
  });

  describe('readProjectStructure', () => {
    it('should read project structure successfully', async () => {
      const mockDirents = [
        { name: 'src', isDirectory: () => true, isFile: () => false },
        { name: 'package.json', isDirectory: () => false, isFile: () => true },
        { name: 'README.md', isDirectory: () => false, isFile: () => true }
      ];

      mockFs.readdir.mockResolvedValue(mockDirents as any);

      const structure = await fileManager.readProjectStructure('/test/project');

      expect(structure.directories).toContain('src');
      expect(structure.files).toContain('package.json');
      expect(structure.files).toContain('README.md');
    });

    it('should handle permission errors gracefully', async () => {
      mockFs.readdir.mockRejectedValue(new Error('Permission denied'));

      const structure = await fileManager.readProjectStructure('/restricted');

      expect(structure.error).toContain('Permission denied');
      expect(structure.directories).toHaveLength(0);
      expect(structure.files).toHaveLength(0);
    });

    it('should validate directory path input', async () => {
      // CRITICAL: Input validation
      const result1 = await fileManager.readProjectStructure('');
      expect(result1.error).toContain('Invalid directory path');

      const result2 = await fileManager.readProjectStructure(null as any);
      expect(result2.error).toContain('Invalid directory path');
    });
  });

  describe('validateCodeQuality', () => {
    it('should validate code against manifesto rules', async () => {
      const codeWithGoodPractices = `
        /**
         * Calculate user age
         * @param birthDate - User's birth date
         * @returns Age in years
         */
        export function calculateAge(birthDate: Date): number {
          try {
            if (!birthDate || !(birthDate instanceof Date)) {
              throw new Error('Invalid birth date');
            }
            
            const today = new Date();
            const age = today.getFullYear() - birthDate.getFullYear();
            return age;
          } catch (error) {
            console.error('Error calculating age:', error);
            throw error;
          }
        }
      `;

      const validation = await fileManager.validateCodeQuality(codeWithGoodPractices);

      expect(validation.isValid).toBe(true);
      expect(validation.score).toBeGreaterThan(80); // Should meet quality standards
    });

    it('should detect manifesto violations', async () => {
      const codeWithViolations = `
        function badFunction(x) {
          return x + 1;
        }
      `;

      const validation = await fileManager.validateCodeQuality(codeWithViolations);

      expect(validation.isValid).toBe(false);
      expect(validation.violations).toContain('Missing JSDoc documentation');
      expect(validation.violations).toContain('Missing error handling');
      expect(validation.violations).toContain('Missing input validation');
    });

    it('should handle empty or invalid code', async () => {
      await expect(fileManager.validateCodeQuality(''))
        .rejects.toThrow('Invalid code content');
      
      await expect(fileManager.validateCodeQuality(null as any))
        .rejects.toThrow('Invalid code content');
    });
  });

  describe('security and error handling', () => {
    it('should prevent path traversal attacks', async () => {
      // CRITICAL: Security requirement - prevent malicious paths
      const maliciousOperation: FileOperation = {
        type: 'create',
        path: '../../../etc/passwd',
        content: 'malicious content'
      };

      const result = await fileManager.writeCodeToFile(maliciousOperation);
      expect(result.success).toBe(false);
      expect(result.error).toContain('path traversal detected');
    });

    it('should sanitize file content for security', async () => {
      const operation: FileOperation = {
        type: 'create',
        path: 'test.ts',
        content: 'console.log("safe"); <script>alert("xss")</script>',
        backup: false
      };

      mockFs.writeFile.mockResolvedValue(undefined);
      mockFs.access.mockRejectedValue(new Error('File not found'));

      const result = await fileManager.writeCodeToFile(operation);

      // Verify XSS content was sanitized
      const writtenContent = mockFs.writeFile.mock.calls[0][1] as string;
      expect(writtenContent).not.toContain('<script>');
    });

    it('should handle concurrent file operations safely', async () => {
      const operations = Array.from({ length: 10 }, (_, i) => ({
        type: 'create' as const,
        path: `concurrent-${i}.ts`,
        content: `content ${i}`
      }));

      mockFs.writeFile.mockResolvedValue(undefined);
      mockFs.access.mockRejectedValue(new Error('File not found'));

      const promises = operations.map(op => fileManager.writeCodeToFile(op));
      const results = await Promise.all(promises);

      // All operations should succeed
      expect(results.every(r => r.success)).toBe(true);
    });

    it('should dispose resources properly', () => {
      const disposeSpy = jest.spyOn(fileManager, 'dispose');
      
      fileManager.dispose();
      
      expect(disposeSpy).toHaveBeenCalled();
    });
  });

  describe('performance monitoring', () => {
    it('should track operation performance', async () => {
      const operation: FileOperation = {
        type: 'create',
        path: 'perf-monitor.ts',
        content: 'test'
      };

      mockFs.writeFile.mockResolvedValue(undefined);
      mockFs.access.mockRejectedValue(new Error('File not found'));

      const result = await fileManager.writeCodeToFile(operation);

      expect(result.performanceMetrics).toBeDefined();
      expect(result.performanceMetrics?.responseTime).toBeLessThan(200);
    });
  });
});

==================== FILE: src/indexing/CodeGraph.ts ====================
import * as vscode from 'vscode';

/**
 * Represents a symbol in the code graph with its relationships
 */
export interface CodeSymbol {
    name: string;
    kind: vscode.SymbolKind;
    location: vscode.Location;
    containerName?: string;
    references: vscode.Location[];
    implementations: vscode.Location[];
    callers: CodeSymbol[];
    callees: CodeSymbol[];
}

/**
 * Advanced code graph that understands relationships between symbols
 * Replaces the simple codebase indexer with intelligent relationship mapping
 */
export class CodeGraph {
    private symbols: Map<string, CodeSymbol> = new Map();
    private fileSymbols: Map<string, CodeSymbol[]> = new Map();
    private isIndexed = false;
    private indexTimestamp = 0;

    /**
     * Build the complete code graph for the workspace
     */
    async buildGraph(): Promise<void> {
        console.log('üîç Building code graph...');
        
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            throw new Error('No workspace folder found');
        }

        // Find all code files
        const files = await vscode.workspace.findFiles(
            '**/*.{ts,js,tsx,jsx,py,java,cs,cpp,h}',
            '**/node_modules/**'
        );

        let processedFiles = 0;
        
        for (const file of files) {
            try {
                await this.indexFile(file);
                processedFiles++;
                
                if (processedFiles % 10 === 0) {
                    console.log(`üìä Processed ${processedFiles}/${files.length} files`);
                }
            } catch (error) {
                console.warn(`Failed to index ${file.fsPath}:`, error);
            }
        }

        // Build relationships after all symbols are indexed
        await this.buildRelationships();
        
        this.isIndexed = true;
        this.indexTimestamp = Date.now();
        console.log(`‚úÖ Code graph built: ${this.symbols.size} symbols, ${files.length} files`);
    }

    /**
     * Index a single file and extract its symbols
     */
    private async indexFile(fileUri: vscode.Uri): Promise<void> {
        const document = await vscode.workspace.openTextDocument(fileUri);
        const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
            'vscode.executeDocumentSymbolProvider',
            fileUri
        );

        if (!symbols) return;

        const fileSymbols: CodeSymbol[] = [];
        
        for (const symbol of symbols) {
            const codeSymbol = await this.createCodeSymbol(symbol, document);
            if (codeSymbol) {
                this.symbols.set(this.getSymbolKey(codeSymbol), codeSymbol);
                fileSymbols.push(codeSymbol);
            }
        }

        this.fileSymbols.set(fileUri.fsPath, fileSymbols);
    }

    /**
     * Create a CodeSymbol from a DocumentSymbol
     */
    private async createCodeSymbol(symbol: vscode.DocumentSymbol, document: vscode.TextDocument): Promise<CodeSymbol | null> {
        try {
            const location = new vscode.Location(document.uri, symbol.range);
            
            // Get references for this symbol
            const references = await vscode.commands.executeCommand<vscode.Location[]>(
                'vscode.executeReferenceProvider',
                document.uri,
                symbol.range.start
            ) || [];

            // Get implementations
            const implementations = await vscode.commands.executeCommand<vscode.Location[]>(
                'vscode.executeImplementationProvider',
                document.uri,
                symbol.range.start
            ) || [];

            return {
                name: symbol.name,
                kind: symbol.kind,
                location,
                containerName: undefined, // DocumentSymbol doesn't have containerName
                references,
                implementations,
                callers: [],
                callees: []
            };
        } catch (error) {
            console.warn(`Failed to create symbol for ${symbol.name}:`, error);
            return null;
        }
    }

    /**
     * Build caller/callee relationships between symbols
     */
    private async buildRelationships(): Promise<void> {
        console.log('üîó Building symbol relationships...');
        
        for (const [, symbol] of this.symbols) {
            // Analyze references to build caller relationships
            for (const ref of symbol.references) {
                const callerSymbol = this.findSymbolAtLocation(ref);
                if (callerSymbol && callerSymbol !== symbol) {
                    symbol.callers.push(callerSymbol);
                    callerSymbol.callees.push(symbol);
                }
            }
        }
    }

    /**
     * Find symbol at a specific location
     */
    private findSymbolAtLocation(location: vscode.Location): CodeSymbol | null {
        const fileSymbols = this.fileSymbols.get(location.uri.fsPath);
        if (!fileSymbols) return null;

        return fileSymbols.find(symbol => 
            symbol.location.range.contains(location.range.start)
        ) || null;
    }

    /**
     * Get unique key for a symbol
     */
    private getSymbolKey(symbol: CodeSymbol): string {
        return `${symbol.location.uri.fsPath}:${symbol.name}:${symbol.kind}`;
    }

    /**
     * Find all references to a symbol by name
     */
    findReferences(symbolName: string): CodeSymbol[] {
        const results: CodeSymbol[] = [];
        
        for (const [, symbol] of this.symbols) {
            if (symbol.name.toLowerCase().includes(symbolName.toLowerCase())) {
                results.push(symbol);
            }
        }
        
        return results;
    }

    /**
     * Analyze impact of changing code at a specific location
     */
    analyzeImpact(fileUri: vscode.Uri, line: number): {
        directImpact: CodeSymbol[];
        indirectImpact: CodeSymbol[];
        riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
    } {
        const position = new vscode.Position(line, 0);
        const location = new vscode.Location(fileUri, position);
        
        const symbol = this.findSymbolAtLocation(location);
        if (!symbol) {
            return { directImpact: [], indirectImpact: [], riskLevel: 'LOW' };
        }

        const directImpact = [...symbol.callers];
        const indirectImpact: CodeSymbol[] = [];
        
        // Find indirect impact (callers of callers)
        for (const caller of symbol.callers) {
            indirectImpact.push(...caller.callers);
        }

        // Assess risk level
        let riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' = 'LOW';
        if (directImpact.length > 10 || indirectImpact.length > 20) {
            riskLevel = 'HIGH';
        } else if (directImpact.length > 3 || indirectImpact.length > 5) {
            riskLevel = 'MEDIUM';
        }

        return { directImpact, indirectImpact, riskLevel };
    }

    /**
     * Get graph statistics
     */
    getStats(): {
        symbolCount: number;
        fileCount: number;
        isIndexed: boolean;
        lastIndexed: number;
    } {
        return {
            symbolCount: this.symbols.size,
            fileCount: this.fileSymbols.size,
            isIndexed: this.isIndexed,
            lastIndexed: this.indexTimestamp
        };
    }

    /**
     * Check if graph needs rebuilding
     */
    needsRebuild(): boolean {
        if (!this.isIndexed) return true;
        
        // Rebuild if older than 1 hour
        const oneHour = 60 * 60 * 1000;
        return (Date.now() - this.indexTimestamp) > oneHour;
    }
}
==================== FILE: src/test/setup.ts ====================
/**
 * Test setup file for Manifesto Code Assistant Pro
 * Following manifesto: comprehensive error handling and testing requirements
 */

// Mock VSCode API for testing
const mockVSCode = {
  window: {
    showInformationMessage: jest.fn(),
    showErrorMessage: jest.fn(),
    showWarningMessage: jest.fn(),
    createStatusBarItem: jest.fn(() => ({
      text: '',
      tooltip: '',
      command: '',
      show: jest.fn(),
      hide: jest.fn(),
      dispose: jest.fn()
    })),
    registerTreeDataProvider: jest.fn()
  },
  workspace: {
    getConfiguration: jest.fn(() => ({
      get: jest.fn(),
      update: jest.fn()
    })),
    workspaceFolders: [],
    onDidChangeConfiguration: jest.fn()
  },
  commands: {
    registerCommand: jest.fn(),
    executeCommand: jest.fn()
  },
  env: {
    clipboard: {
      writeText: jest.fn(),
      readText: jest.fn()
    }
  },
  Uri: {
    file: jest.fn(),
    joinPath: jest.fn()
  },
  StatusBarAlignment: {
    Left: 1,
    Right: 2
  },
  TreeItemCollapsibleState: {
    None: 0,
    Collapsed: 1,
    Expanded: 2
  },
  ThemeColor: jest.fn().mockImplementation((id: string) => ({ id }))  // Mock ThemeColor constructor
};

// Mock crypto module for testing
jest.mock('crypto', () => ({
  scryptSync: jest.fn(() => Buffer.from('test-key-32-bytes-long-for-aes256', 'utf8')),
  randomBytes: jest.fn(() => Buffer.from('1234567890123456', 'utf8')), // 16 bytes for IV
  createCipheriv: jest.fn(() => ({
    update: jest.fn(() => 'encrypteddata'),
    final: jest.fn(() => 'final')
  })),
  createDecipheriv: jest.fn(() => ({
    update: jest.fn(() => 'decrypteddata'),
    final: jest.fn(() => 'final')
  }))
}));

// Global mock for vscode module
jest.mock('vscode', () => mockVSCode, { virtual: true });

// Global test utilities - simple assignment
(global as any).mockVSCode = mockVSCode;

// Reset all mocks before each test
beforeEach(() => {
  jest.clearAllMocks();
});

// Performance monitoring (manifesto requirement: sub-200ms operations)
let testStartTime: number;

beforeEach(() => {
  testStartTime = Date.now();
});

afterEach(() => {
  const testDuration = Date.now() - testStartTime;
  if (testDuration > 200) {
    console.warn(`Test took ${testDuration}ms - exceeds 200ms performance requirement`);
  }
});

==================== FILE: src/ui/PiggieStatusBar.ts ====================
/**
 * Piggie Status Bar Component
 * Following manifesto: MANDATORY error handling, CRITICAL input validation, OPTIMIZE performance
 */

import * as vscode from 'vscode';
import { AgentConfig } from '../core/types';

/**
 * Status bar component for Piggie the manifesto-enforcing chatbot
 * Implements all security and performance requirements from manifesto
 */
export class PiggieStatusBar {
  private statusBarItem: vscode.StatusBarItem;
  private progressTimeout: NodeJS.Timeout | null = null;
  private isDisposed = false;

  constructor() {
    try {
      // MANDATORY: Comprehensive error handling
      this.statusBarItem = vscode.window.createStatusBarItem(
        vscode.StatusBarAlignment.Right, 
        100
      );

      // Initialize with default state
      this.initializeStatusBar();
      this.statusBarItem.show();

    } catch (error) {
      // MANDATORY: Error handling with helpful messages
      const errorMessage = error instanceof Error ? error.message : 'Unknown initialization error';
      throw new Error(`Failed to initialize Piggie status bar: ${errorMessage}`);
    }
  }

  /**
   * Update status bar for manifesto mode changes
   * CRITICAL: Input validation on all user-facing functions
   */
  updateManifestoMode(isManifestoMode: boolean): void {
    try {
      // CRITICAL: Input validation (manifesto requirement)
      if (typeof isManifestoMode !== 'boolean') {
        throw new Error('Invalid manifesto mode: must be boolean');
      }

      if (this.isDisposed) {
        console.warn('Attempted to update disposed status bar');
        return;
      }

      if (isManifestoMode) {
        this.statusBarItem.text = 'üõ°Ô∏è Piggie: Enforcement ENABLED';
        this.statusBarItem.tooltip = 'üê∑ Piggie is enforcing manifesto rules - Click to open chat';
        this.statusBarItem.backgroundColor = undefined;
        this.statusBarItem.command = 'manifestoEnforcer.openSecureChat';
      } else {
        this.statusBarItem.text = '‚ö° Piggie: Enforcement DISABLED';
        this.statusBarItem.tooltip = 'üê∑ Piggie enforcement is disabled - Click to open chat';
        this.statusBarItem.backgroundColor = new vscode.ThemeColor('statusBarItem.warningBackground');
        this.statusBarItem.command = 'manifestoEnforcer.openSecureChat';
      }

    } catch (error) {
      // MANDATORY: Comprehensive error handling
      console.error('Failed to update manifesto mode:', error);
      this.showError('Failed to update Piggie mode');
    }
  }

  /**
   * Update status bar with active agent information
   * CRITICAL: Input validation and XSS prevention
   */
  updateActiveAgent(agentConfig: AgentConfig | null): void {
    try {
      if (this.isDisposed) return;

      // CRITICAL: Input validation
      if (agentConfig && (!agentConfig.id || !agentConfig.name)) {
        throw new Error('Invalid agent configuration: missing required fields');
      }

      let agentText = '';
      let agentTooltip = '';

      if (agentConfig) {
        // CRITICAL: XSS prevention - sanitize input
        const safeName = this.sanitizeText(agentConfig.name);
        agentText = ` | üß† ${safeName}`;
        agentTooltip = `üê∑ Piggie is using: ${safeName} (${agentConfig.provider})`;
      } else {
        agentText = ' | üß† No Agent';
        agentTooltip = 'üê∑ No AI agent selected - Click to choose Piggie\'s brain';
      }

      // Update existing text while preserving manifesto mode info
      const currentText = this.statusBarItem.text;
      const baseText = currentText.split(' | ')[0] || 'üê∑ Piggie';
      
      this.statusBarItem.text = baseText + agentText;
      
      // Combine tooltips - handle both string and MarkdownString types
      const currentTooltip = this.statusBarItem.tooltip || '';
      const currentTooltipText = typeof currentTooltip === 'string' ? currentTooltip : currentTooltip.toString();
      this.statusBarItem.tooltip = currentTooltipText.split('\n')[0] + '\n' + agentTooltip;

    } catch (error) {
      console.error('Failed to update active agent:', error);
      this.showError('Failed to update Piggie\'s brain');
    }
  }

  /**
   * Show progress indicator
   * OPTIMIZE: Efficient UI updates with timeout management
   */
  showProgress(message: string, timeoutMs: number = 30000): void {
    try {
      if (this.isDisposed) return;

      // CRITICAL: Input validation
      if (!message || typeof message !== 'string') {
        throw new Error('Invalid progress message');
      }

      // Clear existing timeout
      if (this.progressTimeout) {
        clearTimeout(this.progressTimeout);
      }

      // Show progress with spinning icon
      const sanitizedMessage = this.sanitizeText(message);
      this.statusBarItem.text = `$(loading~spin) üê∑ ${sanitizedMessage}`;
      this.statusBarItem.tooltip = `üê∑ Piggie is working: ${sanitizedMessage}`;

      // Auto-hide progress after timeout
      this.progressTimeout = setTimeout(() => {
        this.hideProgress();
      }, timeoutMs);

    } catch (error) {
      console.error('Failed to show progress:', error);
    }
  }

  /**
   * Hide progress indicator
   */
  hideProgress(): void {
    try {
      if (this.isDisposed) return;

      if (this.progressTimeout) {
        clearTimeout(this.progressTimeout);
        this.progressTimeout = null;
      }

      // Restore normal status
      this.initializeStatusBar();

    } catch (error) {
      console.error('Failed to hide progress:', error);
    }
  }

  /**
   * Show error state
   * HANDLE: All user-facing errors must have helpful messages
   */
  showError(message: string): void {
    try {
      if (this.isDisposed) return;

      const sanitizedMessage = this.sanitizeText(message);
      this.statusBarItem.text = `‚ùå üê∑ ${sanitizedMessage}`;
      this.statusBarItem.tooltip = `üê∑ Piggie encountered an error: ${sanitizedMessage}`;
      this.statusBarItem.backgroundColor = new vscode.ThemeColor('statusBarItem.errorBackground');

      // Auto-restore after 5 seconds
      setTimeout(() => {
        if (!this.isDisposed) {
          this.initializeStatusBar();
        }
      }, 5000);

    } catch (error) {
      console.error('Failed to show error:', error);
    }
  }

  /**
   * Dispose resources
   * MANDATORY: Proper resource disposal
   */
  dispose(): void {
    try {
      this.isDisposed = true;

      if (this.progressTimeout) {
        clearTimeout(this.progressTimeout);
        this.progressTimeout = null;
      }

      if (this.statusBarItem) {
        this.statusBarItem.dispose();
      }

    } catch (error) {
      console.error('Error disposing status bar:', error);
    }
  }

  // Private helper methods

  private initializeStatusBar(): void {
    this.statusBarItem.text = 'üê∑ Piggie: Ready';
    this.statusBarItem.tooltip = 'üê∑ Piggie - Your manifesto-enforcing AI assistant\nClick to open chat';
    this.statusBarItem.command = 'manifestoEnforcer.openSecureChat';
    this.statusBarItem.backgroundColor = undefined;
  }

  /**
   * Sanitize text to prevent XSS attacks
   * CRITICAL: XSS prevention in all output rendering
   */
  private sanitizeText(text: string): string {
    if (!text || typeof text !== 'string') {
      return '';
    }

    // Remove HTML tags and dangerous characters
    return text
      .replace(/<[^>]*>/g, '') // Remove HTML tags
      .replace(/[<>&"']/g, '') // Remove dangerous characters
      .trim()
      .substring(0, 100); // Limit length to prevent UI overflow
  }
}

==================== FILE: src/ui/__tests__/PiggieStatusBar.test.ts ====================
/**
 * Test suite for PiggieStatusBar
 * Following manifesto: REQUIRED unit tests for all business logic, MANDATORY error handling
 */

import { PiggieStatusBar } from '../PiggieStatusBar';
import { AgentProvider } from '../../core/types';

describe('PiggieStatusBar', () => {
  let statusBar: PiggieStatusBar;
  let mockStatusBarItem: any;

  beforeEach(() => {
    // Mock VSCode status bar item
    mockStatusBarItem = {
      text: '',
      tooltip: '',
      command: '',
      backgroundColor: undefined,
      show: jest.fn(),
      hide: jest.fn(),
      dispose: jest.fn()
    };

    // Mock VSCode window.createStatusBarItem
    (global as any).mockVSCode.window.createStatusBarItem.mockReturnValue(mockStatusBarItem);

    statusBar = new PiggieStatusBar();
  });

  afterEach(() => {
    statusBar.dispose();
  });

  describe('initialization', () => {
    it('should create status bar item successfully', () => {
      expect(mockStatusBarItem.show).toHaveBeenCalled();
      expect(mockStatusBarItem.text).toContain('üê∑');
    });

    it('should handle initialization errors gracefully', () => {
      // Mock createStatusBarItem to throw error
      (global as any).mockVSCode.window.createStatusBarItem.mockImplementation(() => {
        throw new Error('VSCode API error');
      });

      expect(() => new PiggieStatusBar()).toThrow('Failed to initialize Piggie status bar');
    });

    it('should complete initialization within performance requirements', () => {
      const startTime = Date.now();
      
      new PiggieStatusBar();
      
      const duration = Date.now() - startTime;
      expect(duration).toBeLessThan(200); // OPTIMIZE: sub-200ms requirement
    });
  });

  describe('updateManifestoMode', () => {
    it('should update status bar for manifesto mode ON', () => {
      statusBar.updateManifestoMode(true);

      expect(mockStatusBarItem.text).toContain('üõ°Ô∏è');
      expect(mockStatusBarItem.text).toContain('Manifesto ON');
      expect(mockStatusBarItem.tooltip).toContain('Piggie is enforcing manifesto rules');
      expect(mockStatusBarItem.backgroundColor).toBeUndefined();
    });

    it('should update status bar for manifesto mode OFF', () => {
      statusBar.updateManifestoMode(false);

      expect(mockStatusBarItem.text).toContain('‚ö°');
      expect(mockStatusBarItem.text).toContain('Vibe Mode');
      expect(mockStatusBarItem.tooltip).toContain('Piggie is in casual mode');
      expect(mockStatusBarItem.backgroundColor).toBeDefined();
    });

    it('should handle invalid input gracefully', () => {
      // MANDATORY: Input validation - errors are caught and logged, not thrown
      statusBar.updateManifestoMode(null as any);
      statusBar.updateManifestoMode(undefined as any);

      // Verify error was handled (status bar should show error state)
      expect(mockStatusBarItem.text).toContain('‚ùå');
    });
  });

  describe('updateActiveAgent', () => {
    it('should update status bar with active agent info', () => {
      const agentConfig = {
        id: 'test-agent',
        name: 'Test Agent',
        provider: AgentProvider.AUGGIE,
        isEnabled: true
      };

      statusBar.updateActiveAgent(agentConfig);

      expect(mockStatusBarItem.text).toContain('üê∑');
      expect(mockStatusBarItem.text).toContain('Test Agent');
      expect(mockStatusBarItem.tooltip).toContain('Piggie is using: Test Agent');
    });

    it('should handle no active agent', () => {
      statusBar.updateActiveAgent(null);

      expect(mockStatusBarItem.text).toContain('üê∑');
      expect(mockStatusBarItem.text).toContain('No Agent');
      expect(mockStatusBarItem.tooltip).toContain('No AI agent selected');
    });

    it('should validate agent configuration', () => {
      const invalidAgent = {
        id: '',
        name: '',
        provider: AgentProvider.AUGGIE,
        isEnabled: true
      };

      // Error is caught and handled, not thrown
      statusBar.updateActiveAgent(invalidAgent);
      expect(mockStatusBarItem.text).toContain('‚ùå'); // Should show error state
    });
  });

  describe('showProgress', () => {
    it('should show progress indicator', () => {
      statusBar.showProgress('Piggie is thinking...');

      expect(mockStatusBarItem.text).toContain('$(loading~spin)');
      expect(mockStatusBarItem.text).toContain('Piggie is thinking...');
    });

    it('should hide progress indicator', () => {
      statusBar.showProgress('Test');
      statusBar.hideProgress();

      expect(mockStatusBarItem.text).not.toContain('$(loading~spin)');
    });

    it('should handle progress timeout', (done) => {
      statusBar.showProgress('Long operation', 100); // 100ms timeout

      setTimeout(() => {
        expect(mockStatusBarItem.text).not.toContain('$(loading~spin)');
        done();
      }, 150);
    });
  });

  describe('error handling and security', () => {
    it('should handle VSCode API errors gracefully', () => {
      // Mock show() to throw error
      mockStatusBarItem.show.mockImplementation(() => {
        throw new Error('VSCode API error');
      });

      expect(() => statusBar.updateManifestoMode(true)).not.toThrow();
    });

    it('should sanitize tooltip content for security', () => {
      const maliciousTooltip = '<script>alert("xss")</script>';
      
      statusBar.updateManifestoMode(true);
      
      // Verify XSS prevention (CRITICAL security requirement)
      expect(mockStatusBarItem.tooltip).not.toContain('<script>');
    });

    it('should dispose resources properly', () => {
      statusBar.dispose();

      expect(mockStatusBarItem.dispose).toHaveBeenCalled();
    });
  });

  describe('performance monitoring', () => {
    it('should track update performance', () => {
      const startTime = Date.now();
      
      statusBar.updateManifestoMode(true);
      
      const duration = Date.now() - startTime;
      expect(duration).toBeLessThan(50); // Should be very fast for UI updates
    });

    it('should handle rapid updates efficiently', () => {
      const startTime = Date.now();
      
      // Rapid fire updates
      for (let i = 0; i < 100; i++) {
        statusBar.updateManifestoMode(i % 2 === 0);
      }
      
      const duration = Date.now() - startTime;
      expect(duration).toBeLessThan(200); // OPTIMIZE: sub-200ms for 100 updates
    });
  });
});

==================== FILE: src/view/GlossaryTreeDataProvider.ts ====================
import * as vscode from 'vscode';
import { StateManager } from '../core/StateManager';

/**
 * Tree data provider for the Glossary sidebar view
 * Implements the Traditional UI part of the Duality Principle for glossary access
 */
export class GlossaryTreeDataProvider implements vscode.TreeDataProvider<GlossaryItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<GlossaryItem | undefined | null | void> = new vscode.EventEmitter<GlossaryItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<GlossaryItem | undefined | null | void> = this._onDidChangeTreeData.event;

    private glossaryTerms: Map<string, GlossaryTerm> = new Map();

    constructor(private context: vscode.ExtensionContext, private stateManager: StateManager) {
        this.loadGlossary();
    }

    /**
     * Refresh the tree view
     */
    refresh(): void {
        this.loadGlossary();
        this._onDidChangeTreeData.fire();
    }

    /**
     * Get tree item representation
     */
    getTreeItem(element: GlossaryItem): vscode.TreeItem {
        return element;
    }

    /**
     * Get children of a tree item
     */
    getChildren(element?: GlossaryItem): Thenable<GlossaryItem[]> {
        if (!element) {
            // Root level - return all terms
            if (this.glossaryTerms.size === 0) {
                return Promise.resolve([
                    new GlossaryItem(
                        'No Terms Defined',
                        'Use chat commands to add terms: "Define API as Application Programming Interface"',
                        'empty'
                    )
                ]);
            }

            const sortedTerms = Array.from(this.glossaryTerms.values())
                .sort((a, b) => a.term.localeCompare(b.term));

            return Promise.resolve(sortedTerms.map(term => 
                new GlossaryItem(
                    term.term,
                    term.definition,
                    'term',
                    term.usage
                )
            ));
        }
        
        return Promise.resolve([]);
    }

    /**
     * Load glossary from StateManager
     */
    private loadGlossary(): void {
        try {
            // Sync with StateManager's projectGlossary
            this.glossaryTerms = new Map(this.stateManager.projectGlossary);
        } catch (error) {
            console.error('Failed to load glossary:', error);
        }
    }

    /**
     * Add a new term to the glossary
     */
    async addTerm(term: string, definition: string): Promise<void> {
        const glossaryTerm: GlossaryTerm = {
            term,
            definition,
            dateAdded: Date.now(),
            usage: 0
        };

        this.stateManager.projectGlossary.set(term.toUpperCase(), glossaryTerm);
        await this.saveGlossary();
        this.refresh();
    }

    /**
     * Remove a term from the glossary
     */
    async removeTerm(term: string): Promise<void> {
        this.stateManager.projectGlossary.delete(term.toUpperCase());
        await this.saveGlossary();
        this.refresh();
    }

    /**
     * Update term usage
     */
    async incrementUsage(term: string): Promise<void> {
        const upperTerm = term.toUpperCase();
        const glossaryTerm = this.stateManager.projectGlossary.get(upperTerm);
        if (glossaryTerm) {
            glossaryTerm.usage++;
            await this.saveGlossary();
            this.refresh();
        }
    }

    /**
     * Save glossary to extension storage
     */
    private async saveGlossary(): Promise<void> {
        try {
            const glossaryObject: any = {};
            for (const [key, value] of this.stateManager.projectGlossary) {
                glossaryObject[key] = value;
            }
            await this.context.workspaceState.update('projectGlossary', {
                timestamp: Date.now(),
                terms: Array.from(this.stateManager.projectGlossary.entries()).map(([key, value]) => ({
                    key,
                    term: value.term,
                    definition: value.definition,
                    dateAdded: value.dateAdded,
                    usage: value.usage
                }))
            });
        } catch (error) {
            console.error('Failed to save glossary:', error);
        }
    }

    /**
     * Get all terms
     */
    getTerms(): Map<string, GlossaryTerm> {
        return new Map(this.stateManager.projectGlossary);
    }

    /**
     * Search for terms
     */
    searchTerms(query: string): GlossaryTerm[] {
        const results: GlossaryTerm[] = [];
        const lowerQuery = query.toLowerCase();
        
        for (const term of this.stateManager.projectGlossary.values()) {
            if (term.term.toLowerCase().includes(lowerQuery) || 
                term.definition.toLowerCase().includes(lowerQuery)) {
                results.push(term);
            }
        }
        
        return results.sort((a, b) => a.term.localeCompare(b.term));
    }

    /**
     * Get term by name
     */
    getTerm(termName: string): GlossaryTerm | undefined {
        return this.stateManager.projectGlossary.get(termName.toUpperCase());
    }

    /**
     * Export glossary to JSON
     */
    exportToJSON(): string {
        const exportData: any = {};
        for (const [key, value] of this.stateManager.projectGlossary) {
            exportData[value.term] = value.definition;
        }
        return JSON.stringify(exportData, null, 2);
    }

    /**
     * Import glossary from JSON
     */
    async importFromJSON(jsonContent: string): Promise<number> {
        try {
            const data = JSON.parse(jsonContent);
            let importedCount = 0;
            
            for (const [term, definition] of Object.entries(data)) {
                if (typeof definition === 'string') {
                    await this.addTerm(term, definition);
                    importedCount++;
                }
            }
            
            return importedCount;
        } catch (error) {
            throw new Error(`Invalid JSON format: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}

/**
 * Represents a glossary item in the tree view
 */
export class GlossaryItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly definition: string,
        public readonly type: 'term' | 'empty',
        public readonly usage: number = 0
    ) {
        super(label, vscode.TreeItemCollapsibleState.None);
        
        if (type === 'term') {
            this.tooltip = `${label}: ${definition}\nUsed ${usage} time${usage !== 1 ? 's' : ''}`;
            this.description = `${definition.substring(0, 40)}${definition.length > 40 ? '...' : ''}`;
            this.iconPath = new vscode.ThemeIcon('book');
            
            // Show usage count if > 0
            if (usage > 0) {
                this.description += ` (${usage}x)`;
            }
            
            // Make clickable to show full definition
            this.command = {
                command: 'manifestoEnforcer.showGlossaryTerm',
                title: 'Show Definition',
                arguments: [this]
            };
        } else {
            this.tooltip = definition;
            this.iconPath = new vscode.ThemeIcon('info');
        }

        this.contextValue = type;
    }
}

/**
 * Represents a glossary term
 */
export interface GlossaryTerm {
    term: string;
    definition: string;
    dateAdded: number;
    usage: number;
}

==================== FILE: src/view/InteractiveDiffProvider.ts ====================
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { StateManager } from '../core/StateManager';

/**
 * Provides interactive diff functionality for AI-suggested code changes
 * Implements the Traditional UI part of the Duality Principle
 */
export class InteractiveDiffProvider {
    private context: vscode.ExtensionContext;

    constructor(context: vscode.ExtensionContext, private stateManager: StateManager) {
        this.context = context;
    }

    /**
     * Show a diff view comparing original and AI-suggested code
     * This is the Traditional UI access point for code changes
     */
    async showDiff(
        originalContent: string,
        suggestedContent: string,
        fileName: string,
        description: string
    ): Promise<boolean> {
        try {
            // Create temporary files for diff comparison
            const tempDir = path.join(this.context.globalStorageUri.fsPath, 'diffs');
            await fs.promises.mkdir(tempDir, { recursive: true });

            const originalFile = path.join(tempDir, `${fileName}.original`);
            const suggestedFile = path.join(tempDir, `${fileName}.suggested`);

            // Write content to temporary files
            await fs.promises.writeFile(originalFile, originalContent, 'utf8');
            await fs.promises.writeFile(suggestedFile, suggestedContent, 'utf8');

            // Create URIs for the diff
            const originalUri = vscode.Uri.file(originalFile);
            const suggestedUri = vscode.Uri.file(suggestedFile);

            // Show the diff in VS Code
            await vscode.commands.executeCommand(
                'vscode.diff',
                originalUri,
                suggestedUri,
                `${description} - ${fileName}`,
                {
                    preview: true,
                    preserveFocus: false
                }
            );

            // Show action buttons
            const action = await vscode.window.showInformationMessage(
                `Review the suggested changes for ${fileName}`,
                {
                    modal: true,
                    detail: description
                },
                'Apply Changes',
                'Reject Changes',
                'Edit Manually'
            );

            // Clean up temporary files
            try {
                await fs.promises.unlink(originalFile);
                await fs.promises.unlink(suggestedFile);
            } catch (cleanupError) {
                console.warn('Failed to clean up temp files:', cleanupError);
            }

            if (action === 'Apply Changes') {
                return await this.applyChanges(fileName, suggestedContent);
            } else if (action === 'Edit Manually') {
                return await this.openForManualEdit(fileName, suggestedContent);
            }

            return false; // Changes rejected

        } catch (error) {
            vscode.window.showErrorMessage(`Failed to show diff: ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }

    /**
     * Apply the suggested changes to the actual file
     */
    private async applyChanges(fileName: string, newContent: string): Promise<boolean> {
        try {
            // Find the actual file in the workspace
            const files = await vscode.workspace.findFiles(`**/${fileName}`);
            if (files.length === 0) {
                vscode.window.showErrorMessage(`File ${fileName} not found in workspace`);
                return false;
            }

            const fileUri = files[0]; // Use first match
            const document = await vscode.workspace.openTextDocument(fileUri);
            
            // Apply the changes
            const edit = new vscode.WorkspaceEdit();
            const fullRange = new vscode.Range(
                document.positionAt(0),
                document.positionAt(document.getText().length)
            );
            edit.replace(fileUri, fullRange, newContent);

            const success = await vscode.workspace.applyEdit(edit);
            if (success) {
                // Save the file
                await document.save();
                vscode.window.showInformationMessage(`‚úÖ Changes applied to ${fileName}`);
                
                // Open the file to show the changes
                await vscode.window.showTextDocument(document);
                return true;
            } else {
                vscode.window.showErrorMessage(`Failed to apply changes to ${fileName}`);
                return false;
            }

        } catch (error) {
            vscode.window.showErrorMessage(`Error applying changes: ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }

    /**
     * Open the file for manual editing with suggested content in a new editor
     */
    private async openForManualEdit(fileName: string, suggestedContent: string): Promise<boolean> {
        try {
            // Create a new untitled document with the suggested content
            const document = await vscode.workspace.openTextDocument({
                content: suggestedContent,
                language: this.getLanguageFromFileName(fileName)
            });

            await vscode.window.showTextDocument(document);
            
            vscode.window.showInformationMessage(
                `Opened suggested changes for manual editing. Save as ${fileName} when ready.`
            );
            
            return true;

        } catch (error) {
            vscode.window.showErrorMessage(`Error opening for manual edit: ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }

    /**
     * Determine the language ID from file extension
     */
    private getLanguageFromFileName(fileName: string): string {
        const ext = path.extname(fileName).toLowerCase();
        const languageMap: { [key: string]: string } = {
            '.ts': 'typescript',
            '.js': 'javascript',
            '.tsx': 'typescriptreact',
            '.jsx': 'javascriptreact',
            '.py': 'python',
            '.java': 'java',
            '.cs': 'csharp',
            '.cpp': 'cpp',
            '.c': 'c',
            '.h': 'c',
            '.hpp': 'cpp',
            '.md': 'markdown',
            '.json': 'json',
            '.html': 'html',
            '.css': 'css',
            '.scss': 'scss',
            '.less': 'less'
        };

        return languageMap[ext] || 'plaintext';
    }

    /**
     * Show a quick diff preview in a new editor (alternative method)
     */
    async showQuickDiff(
        originalContent: string,
        suggestedContent: string,
        fileName: string
    ): Promise<void> {
        try {
            // Create a diff document
            const diffContent = this.createDiffContent(originalContent, suggestedContent, fileName);
            
            const document = await vscode.workspace.openTextDocument({
                content: diffContent,
                language: 'diff'
            });

            await vscode.window.showTextDocument(document, {
                preview: true,
                preserveFocus: false
            });

        } catch (error) {
            vscode.window.showErrorMessage(`Failed to show quick diff: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Create a unified diff format content
     */
    private createDiffContent(original: string, suggested: string, fileName: string): string {
        const originalLines = original.split('\n');
        const suggestedLines = suggested.split('\n');
        
        let diff = `--- ${fileName} (original)\n`;
        diff += `+++ ${fileName} (suggested)\n`;
        diff += `@@ -1,${originalLines.length} +1,${suggestedLines.length} @@\n`;
        
        // Simple line-by-line diff (could be enhanced with proper diff algorithm)
        const maxLines = Math.max(originalLines.length, suggestedLines.length);
        
        for (let i = 0; i < maxLines; i++) {
            const originalLine = originalLines[i];
            const suggestedLine = suggestedLines[i];
            
            if (originalLine === undefined) {
                diff += `+${suggestedLine}\n`;
            } else if (suggestedLine === undefined) {
                diff += `-${originalLine}\n`;
            } else if (originalLine !== suggestedLine) {
                diff += `-${originalLine}\n`;
                diff += `+${suggestedLine}\n`;
            } else {
                diff += ` ${originalLine}\n`;
            }
        }
        
        return diff;
    }
}

==================== FILE: src/view/ManifestoRulesProvider.ts ====================
import * as vscode from 'vscode';
import { StateManager } from '../core/StateManager';

/**
 * Tree data provider for Manifesto Rules view
 * Shows manifesto management actions and rules
 */
export class ManifestoRulesProvider implements vscode.TreeDataProvider<RuleItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<RuleItem | undefined | null | void> = new vscode.EventEmitter<RuleItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<RuleItem | undefined | null | void> = this._onDidChangeTreeData.event;

    constructor(private stateManager: StateManager) {}

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: RuleItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: RuleItem): Thenable<RuleItem[]> {
        if (!element) {
            // Root level - show manifesto actions
            return Promise.resolve([
                new RuleItem('Toggle Manifesto Mode', 'üõ°Ô∏è Toggle Manifesto Mode', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.toggleManifestoMode',
                    title: 'Toggle Manifesto Mode'
                }),
                new RuleItem('Create Manifesto', 'üìù Create New Manifesto', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.createManifesto',
                    title: 'Create Manifesto'
                }),
                new RuleItem('Refresh Manifesto', 'üîÑ Refresh Manifesto', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.refreshManifesto',
                    title: 'Refresh Manifesto'
                }),
                new RuleItem('Validate Compliance', '‚úÖ Validate Compliance', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.validateCompliance',
                    title: 'Validate Compliance'
                }),
                new RuleItem('Settings', '‚öôÔ∏è Open Settings', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.openSettings',
                    title: 'Open Settings'
                })
            ]);
        }
        return Promise.resolve([]);
    }
}

class RuleItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly tooltip: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState,
        public readonly command?: vscode.Command
    ) {
        super(label, collapsibleState);
        this.tooltip = tooltip;
        this.command = command;
    }
}

==================== FILE: src/view/ManifestoTreeDataProvider.ts ====================
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { StateManager } from '../core/StateManager';

/**
 * Tree data provider for the Manifesto sidebar view
 * Implements the Traditional UI part of the Duality Principle for manifesto access
 */
export class ManifestoTreeDataProvider implements vscode.TreeDataProvider<ManifestoItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<ManifestoItem | undefined | null | void> = new vscode.EventEmitter<ManifestoItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<ManifestoItem | undefined | null | void> = this._onDidChangeTreeData.event;

    private manifestoContent: string = '';
    private manifestoSections: ManifestoSection[] = [];

    constructor(private stateManager: StateManager) {
        this.loadManifesto();
    }

    /**
     * Refresh the tree view
     */
    refresh(): void {
        this.loadManifesto();
        this._onDidChangeTreeData.fire();
    }

    /**
     * Get tree item representation
     */
    getTreeItem(element: ManifestoItem): vscode.TreeItem {
        return element;
    }

    /**
     * Get children of a tree item
     */
    getChildren(element?: ManifestoItem): Thenable<ManifestoItem[]> {
        if (!element) {
            // Root level - return sections
            return Promise.resolve(this.manifestoSections.map(section => 
                new ManifestoItem(
                    section.title,
                    section.content,
                    vscode.TreeItemCollapsibleState.Collapsed,
                    'section'
                )
            ));
        } else if (element.type === 'section') {
            // Section level - return rules
            const section = this.manifestoSections.find(s => s.title === element.label);
            if (section) {
                return Promise.resolve(section.rules.map(rule => 
                    new ManifestoItem(
                        rule.title,
                        rule.content,
                        vscode.TreeItemCollapsibleState.None,
                        'rule'
                    )
                ));
            }
        }
        
        return Promise.resolve([]);
    }

    /**
     * Load manifesto content from file
     */
    private async loadManifesto(): Promise<void> {
        try {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                this.manifestoSections = [{
                    title: 'No Workspace',
                    content: 'Open a workspace to view manifesto',
                    rules: []
                }];
                return;
            }

            // Look for manifesto files
            const manifestoFiles = await vscode.workspace.findFiles(
                '**/*{manifesto,standards,guidelines,rules}*.{md,txt}',
                '**/node_modules/**'
            );

            if (manifestoFiles.length === 0) {
                this.manifestoSections = [{
                    title: 'No Manifesto Found',
                    content: 'Create a manifesto.md file to get started',
                    rules: [{
                        title: 'Create Manifesto',
                        content: 'Use the chat command: /manifesto or create manifesto.md manually'
                    }]
                }];
                return;
            }

            // Read the first manifesto file
            const manifestoFile = manifestoFiles[0];
            const document = await vscode.workspace.openTextDocument(manifestoFile);
            this.manifestoContent = document.getText();
            
            // Parse the manifesto content
            this.parseManifestoContent();

        } catch (error) {
            console.error('Failed to load manifesto:', error);
            this.manifestoSections = [{
                title: 'Error Loading Manifesto',
                content: `Failed to load: ${error instanceof Error ? error.message : String(error)}`,
                rules: []
            }];
        }
    }

    /**
     * Parse manifesto markdown content into sections and rules
     */
    private parseManifestoContent(): void {
        const lines = this.manifestoContent.split('\n');
        const sections: ManifestoSection[] = [];
        let currentSection: ManifestoSection | null = null;
        let currentRule: ManifestoRule | null = null;
        let contentBuffer: string[] = [];

        for (const line of lines) {
            const trimmedLine = line.trim();
            
            // Main section headers (## or #)
            if (trimmedLine.match(/^#{1,2}\s+/)) {
                // Save previous rule if exists
                if (currentRule && contentBuffer.length > 0) {
                    currentRule.content = contentBuffer.join('\n').trim();
                    contentBuffer = [];
                }
                
                // Save previous section if exists
                if (currentSection && currentRule) {
                    currentSection.rules.push(currentRule);
                    currentRule = null;
                }
                
                if (currentSection) {
                    sections.push(currentSection);
                }

                // Start new section
                const title = trimmedLine.replace(/^#{1,2}\s+/, '');
                currentSection = {
                    title,
                    content: '',
                    rules: []
                };
                
            } else if (trimmedLine.match(/^#{3,}\s+/) && currentSection) {
                // Sub-section headers (### or more) - treat as rules
                if (currentRule && contentBuffer.length > 0) {
                    currentRule.content = contentBuffer.join('\n').trim();
                    currentSection.rules.push(currentRule);
                    contentBuffer = [];
                }

                const title = trimmedLine.replace(/^#{3,}\s+/, '');
                currentRule = {
                    title,
                    content: ''
                };
                
            } else if (trimmedLine.startsWith('- **') || trimmedLine.startsWith('* **')) {
                // Bullet points with bold text - treat as rules
                if (!currentSection) {
                    currentSection = {
                        title: 'General Rules',
                        content: '',
                        rules: []
                    };
                }

                if (currentRule && contentBuffer.length > 0) {
                    currentRule.content = contentBuffer.join('\n').trim();
                    currentSection.rules.push(currentRule);
                    contentBuffer = [];
                }

                const match = trimmedLine.match(/^[-*]\s+\*\*([^*]+)\*\*/);
                if (match) {
                    currentRule = {
                        title: match[1],
                        content: trimmedLine
                    };
                }
                
            } else if (trimmedLine.length > 0) {
                // Regular content
                contentBuffer.push(line);
            }
        }

        // Save final rule and section
        if (currentRule && contentBuffer.length > 0) {
            currentRule.content = contentBuffer.join('\n').trim();
        }
        if (currentSection && currentRule) {
            currentSection.rules.push(currentRule);
        }
        if (currentSection) {
            sections.push(currentSection);
        }

        this.manifestoSections = sections.length > 0 ? sections : [{
            title: 'Empty Manifesto',
            content: 'The manifesto file appears to be empty',
            rules: []
        }];
    }

    /**
     * Get the full manifesto content
     */
    getManifestoContent(): string {
        return this.manifestoContent;
    }

    /**
     * Get manifesto sections
     */
    getSections(): ManifestoSection[] {
        return this.manifestoSections;
    }
}

/**
 * Represents a manifesto item in the tree view
 */
export class ManifestoItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly content: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState,
        public readonly type: 'section' | 'rule'
    ) {
        super(label, collapsibleState);
        
        this.tooltip = content;
        this.description = type === 'section' ? '' : content.substring(0, 50) + (content.length > 50 ? '...' : '');
        
        // Set icons
        if (type === 'section') {
            this.iconPath = new vscode.ThemeIcon('folder');
        } else {
            this.iconPath = new vscode.ThemeIcon('shield');
        }

        // Set context value for commands
        this.contextValue = type;
        
        // Make rules clickable to show content
        if (type === 'rule') {
            this.command = {
                command: 'manifestoEnforcer.showManifestoRule',
                title: 'Show Rule',
                arguments: [this]
            };
        }
    }
}

/**
 * Represents a manifesto section
 */
interface ManifestoSection {
    title: string;
    content: string;
    rules: ManifestoRule[];
}

/**
 * Represents a manifesto rule
 */
interface ManifestoRule {
    title: string;
    content: string;
}

==================== FILE: src/view/PiggieActionsProvider.ts ====================
import * as vscode from 'vscode';

/**
 * Tree data provider for Piggie Actions view
 * Shows available Piggie commands and actions
 */
export class PiggieActionsProvider implements vscode.TreeDataProvider<ActionItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<ActionItem | undefined | null | void> = new vscode.EventEmitter<ActionItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<ActionItem | undefined | null | void> = this._onDidChangeTreeData.event;

    constructor() {}

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: ActionItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: ActionItem): Thenable<ActionItem[]> {
        if (!element) {
            // Root level - show main action categories
            return Promise.resolve([
                new ActionItem('Quick Chat', 'üí¨ Quick Chat with Piggie', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.quickChat',
                    title: 'Quick Chat'
                }),
                new ActionItem('Write Code', 'üìù Write Code', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.writeCode',
                    title: 'Write Code'
                }),
                new ActionItem('Validate Compliance', '‚úÖ Validate Compliance', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.validateCompliance',
                    title: 'Validate Compliance'
                }),
                new ActionItem('Switch Agent', 'ü§ñ Switch AI Agent', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.switchAgent',
                    title: 'Switch Agent'
                }),
                new ActionItem('Test Connection', 'üîß Test Connection', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.testConnection',
                    title: 'Test Connection'
                }),
                new ActionItem('Discover APIs', 'üîç Discover APIs', vscode.TreeItemCollapsibleState.None, {
                    command: 'piggie.discoverAPIs',
                    title: 'Discover APIs'
                })
            ]);
        }
        return Promise.resolve([]);
    }
}

class ActionItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly tooltip: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState,
        public readonly command?: vscode.Command
    ) {
        super(label, collapsibleState);
        this.tooltip = tooltip;
        this.command = command;
    }
}

==================== FILE: src/view/SecurityReviewProvider.ts ====================
import * as vscode from 'vscode';

/**
 * Tree data provider for Security Review view
 * Shows security-related actions and tools
 */
export class SecurityReviewProvider implements vscode.TreeDataProvider<SecurityItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<SecurityItem | undefined | null | void> = new vscode.EventEmitter<SecurityItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<SecurityItem | undefined | null | void> = this._onDidChangeTreeData.event;

    constructor() {}

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: SecurityItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: SecurityItem): Thenable<SecurityItem[]> {
        if (!element) {
            // Root level - show security actions
            return Promise.resolve([
                new SecurityItem('Review Selected Code', 'üîç Review Selected Code', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.reviewSelectedCode',
                    title: 'Review Selected Code'
                }),
                new SecurityItem('Security Scan', 'üõ°Ô∏è Run Security Scan', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.validateCompliance',
                    title: 'Security Scan'
                }),
                new SecurityItem('Refactor Code', '‚ôªÔ∏è Refactor Selected Code', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.refactorSelectedCode',
                    title: 'Refactor Code'
                }),
                new SecurityItem('Explain Code', '‚ùì Explain Selected Code', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.explainSelectedCode',
                    title: 'Explain Code'
                }),
                new SecurityItem('Send to Amazon Q', 'üü† Send to Amazon Q', vscode.TreeItemCollapsibleState.None, {
                    command: 'manifestoEnforcer.sendToAmazonQ',
                    title: 'Send to Amazon Q'
                })
            ]);
        }
        return Promise.resolve([]);
    }
}

class SecurityItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly tooltip: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState,
        public readonly command?: vscode.Command
    ) {
        super(label, collapsibleState);
        this.tooltip = tooltip;
        this.command = command;
    }
}
